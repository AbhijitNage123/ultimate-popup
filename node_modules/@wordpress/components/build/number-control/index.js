"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberControl = NumberControl;
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _i18n = require("@wordpress/i18n");

var _numberControlStyles = require("./styles/number-control-styles");

var _state = require("../input-control/state");

var _math = require("../utils/math");

var _hooks = require("../utils/hooks");

var _values = require("../utils/values");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function NumberControl({
  __unstableStateReducer: stateReducer = state => state,
  className,
  dragDirection = 'n',
  hideHTMLArrows = false,
  isDragEnabled = true,
  isShiftStepEnabled = true,
  label,
  max = Infinity,
  min = -Infinity,
  shiftStep = 10,
  step = 1,
  type: typeProp = 'number',
  value: valueProp,
  ...props
}, ref) {
  const baseValue = (0, _math.roundClamp)(0, min, max, step);
  const jumpStep = (0, _hooks.useJumpStep)({
    step,
    shiftStep,
    isShiftStepEnabled
  });
  const autoComplete = typeProp === 'number' ? 'off' : null;
  const classes = (0, _classnames.default)('components-number-control', className);
  /**
   * "Middleware" function that intercepts updates from InputControl.
   * This allows us to tap into actions to transform the (next) state for
   * InputControl.
   *
   * @param {Object} state  State from InputControl
   * @param {Object} action Action triggering state change
   * @return {Object} The updated state to apply to InputControl
   */

  const numberControlStateReducer = (state, action) => {
    const {
      type,
      payload
    } = action;
    const event = payload === null || payload === void 0 ? void 0 : payload.event;
    const currentValue = state.value;
    /**
     * Handles custom UP and DOWN Keyboard events
     */

    if (type === _state.inputControlActionTypes.PRESS_UP || type === _state.inputControlActionTypes.PRESS_DOWN) {
      const enableShift = event.shiftKey && isShiftStepEnabled;
      const incrementalValue = enableShift ? parseFloat(shiftStep) * parseFloat(step) : parseFloat(step);
      let nextValue = (0, _values.isValueEmpty)(currentValue) ? baseValue : currentValue;

      if (event !== null && event !== void 0 && event.preventDefault) {
        event.preventDefault();
      }

      if (type === _state.inputControlActionTypes.PRESS_UP) {
        nextValue = (0, _math.add)(nextValue, incrementalValue);
      }

      if (type === _state.inputControlActionTypes.PRESS_DOWN) {
        nextValue = (0, _math.subtract)(nextValue, incrementalValue);
      }

      nextValue = (0, _math.roundClamp)(nextValue, min, max, incrementalValue);
      state.value = nextValue;
    }
    /**
     * Handles drag to update events
     */


    if (type === _state.inputControlActionTypes.DRAG && isDragEnabled) {
      const {
        delta,
        shiftKey
      } = payload;
      const [x, y] = delta;
      const modifier = shiftKey ? parseFloat(shiftStep) * parseFloat(step) : parseFloat(step);
      let directionModifier;
      let directionBaseValue;

      switch (dragDirection) {
        case 'n':
          directionBaseValue = y;
          directionModifier = -1;
          break;

        case 'e':
          directionBaseValue = x;
          directionModifier = (0, _i18n.isRTL)() ? -1 : 1;
          break;

        case 's':
          directionBaseValue = y;
          directionModifier = 1;
          break;

        case 'w':
          directionBaseValue = x;
          directionModifier = (0, _i18n.isRTL)() ? 1 : -1;
          break;
      }

      const distance = directionBaseValue * modifier * directionModifier;
      let nextValue;

      if (distance !== 0) {
        nextValue = (0, _math.roundClamp)((0, _math.add)(currentValue, distance), min, max, modifier);
        state.value = nextValue;
      }
    }
    /**
     * Handles commit (ENTER key press or on blur if isPressEnterToChange)
     */


    if (type === _state.inputControlActionTypes.PRESS_ENTER || type === _state.inputControlActionTypes.COMMIT) {
      state.value = (0, _math.roundClamp)(currentValue, min, max, step);
    }

    return state;
  };

  return (0, _element.createElement)(_numberControlStyles.Input, (0, _extends2.default)({
    autoComplete: autoComplete,
    inputMode: "numeric"
  }, props, {
    className: classes,
    dragDirection: dragDirection,
    hideHTMLArrows: hideHTMLArrows,
    isDragEnabled: isDragEnabled,
    label: label,
    max: max,
    min: min,
    ref: ref,
    step: jumpStep,
    type: typeProp,
    value: valueProp,
    __unstableStateReducer: (0, _state.composeStateReducers)(numberControlStateReducer, stateReducer)
  }));
}

var _default = (0, _element.forwardRef)(NumberControl);

exports.default = _default;
//# sourceMappingURL=index.js.map