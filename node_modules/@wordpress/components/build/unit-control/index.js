"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "parseUnit", {
  enumerable: true,
  get: function () {
    return _utils.parseUnit;
  }
});
Object.defineProperty(exports, "useCustomUnits", {
  enumerable: true,
  get: function () {
    return _utils.useCustomUnits;
  }
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _lodash = require("lodash");

var _classnames = _interopRequireDefault(require("classnames"));

var _i18n = require("@wordpress/i18n");

var _keycodes = require("@wordpress/keycodes");

var _state = require("../input-control/state");

var _unitControlStyles = require("./styles/unit-control-styles");

var _unitSelectControl = _interopRequireDefault(require("./unit-select-control"));

var _utils = require("./utils");

var _hooks = require("../utils/hooks");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function UnitControl({
  __unstableStateReducer: stateReducer = state => state,
  autoComplete = 'off',
  className,
  disabled = false,
  disableUnits = false,
  isPressEnterToChange = false,
  isResetValueOnUnitChange = false,
  isUnitSelectTabbable = true,
  label,
  onChange = _lodash.noop,
  onUnitChange = _lodash.noop,
  size = 'default',
  style,
  unit: unitProp,
  units = _utils.CSS_UNITS,
  value: valueProp,
  ...props
}, ref) {
  const [value, initialUnit] = (0, _utils.getParsedValue)(valueProp, unitProp, units);
  const [unit, setUnit] = (0, _hooks.useControlledState)(unitProp, {
    initial: initialUnit
  }); // Stores parsed value for hand-off in state reducer

  const refParsedValue = (0, _element.useRef)(null);
  const classes = (0, _classnames.default)('components-unit-control', className);

  const handleOnChange = (next, changeProps) => {
    if (next === '') {
      onChange('', changeProps);
      return;
    }
    /*
     * Customizing the onChange callback.
     * This allows as to broadcast a combined value+unit to onChange.
     */


    next = (0, _utils.getValidParsedUnit)(next, units, value, unit).join('');
    onChange(next, changeProps);
  };

  const handleOnUnitChange = (next, changeProps) => {
    const {
      data
    } = changeProps;
    let nextValue = `${value}${next}`;

    if (isResetValueOnUnitChange && (data === null || data === void 0 ? void 0 : data.default) !== undefined) {
      nextValue = `${data.default}${next}`;
    }

    onChange(nextValue, changeProps);
    onUnitChange(next, changeProps);
    setUnit(next);
  };

  const mayUpdateUnit = event => {
    if (!isNaN(event.target.value)) {
      refParsedValue.current = null;
      return;
    }

    const [parsedValue, parsedUnit] = (0, _utils.getValidParsedUnit)(event.target.value, units, value, unit);
    refParsedValue.current = parsedValue;

    if (isPressEnterToChange && parsedUnit !== unit) {
      const data = units.find(option => option.value === parsedUnit);
      const changeProps = {
        event,
        data
      };
      onChange(`${parsedValue}${parsedUnit}`, changeProps);
      onUnitChange(parsedUnit, changeProps);
      setUnit(parsedUnit);
    }
  };

  const handleOnBlur = mayUpdateUnit;

  const handleOnKeyDown = event => {
    const {
      keyCode
    } = event;

    if (keyCode === _keycodes.ENTER) {
      mayUpdateUnit(event);
    }
  };
  /**
   * "Middleware" function that intercepts updates from InputControl.
   * This allows us to tap into actions to transform the (next) state for
   * InputControl.
   *
   * @param {Object} state  State from InputControl
   * @param {Object} action Action triggering state change
   * @return {Object} The updated state to apply to InputControl
   */


  const unitControlStateReducer = (state, action) => {
    /*
     * On commits (when pressing ENTER and on blur if
     * isPressEnterToChange is true), if a parse has been performed
     * then use that result to update the state.
     */
    if (action.type === _state.inputControlActionTypes.COMMIT) {
      if (refParsedValue.current !== null) {
        state.value = refParsedValue.current;
        refParsedValue.current = null;
      }
    }

    return state;
  };

  const inputSuffix = !disableUnits ? (0, _element.createElement)(_unitSelectControl.default, {
    "aria-label": (0, _i18n.__)('Select unit'),
    disabled: disabled,
    isTabbable: isUnitSelectTabbable,
    options: units,
    onChange: handleOnUnitChange,
    size: size,
    value: unit
  }) : null;
  let step = props.step;
  /*
   * If no step prop has been passed, lookup the active unit and
   * try to get step from `units`, or default to a value of `1`
   */

  if (!step && units) {
    var _activeUnit$step;

    const activeUnit = units.find(option => option.value === unit);
    step = (_activeUnit$step = activeUnit === null || activeUnit === void 0 ? void 0 : activeUnit.step) !== null && _activeUnit$step !== void 0 ? _activeUnit$step : 1;
  }

  return (0, _element.createElement)(_unitControlStyles.Root, {
    className: "components-unit-control-wrapper",
    style: style
  }, (0, _element.createElement)(_unitControlStyles.ValueInput, (0, _extends2.default)({
    "aria-label": label,
    type: isPressEnterToChange ? 'text' : 'number'
  }, (0, _lodash.omit)(props, ['children']), {
    autoComplete: autoComplete,
    className: classes,
    disabled: disabled,
    disableUnits: disableUnits,
    isPressEnterToChange: isPressEnterToChange,
    label: label,
    onBlur: handleOnBlur,
    onKeyDown: handleOnKeyDown,
    onChange: handleOnChange,
    ref: ref,
    size: size,
    suffix: inputSuffix,
    value: value,
    step: step,
    __unstableStateReducer: (0, _state.composeStateReducers)(unitControlStateReducer, stateReducer)
  })));
}

const ForwardedUnitControl = (0, _element.forwardRef)(UnitControl);
var _default = ForwardedUnitControl;
exports.default = _default;
//# sourceMappingURL=index.js.map