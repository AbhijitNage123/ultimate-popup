{"version":3,"sources":["@wordpress/components/src/utils/hooks/use-cx.ts"],"names":["CacheProvider","insertStyles","cx","innerCx","useContext","useCallback","EmotionCacheContext","_context","useEmotionCacheContext","isSerializedStyles","o","every","p","useCx","cache","classNames","map","arg","key","name"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,SAASA,aAAT,QAA4C,gBAA5C;AAEA,SAASC,YAAT,QAA6B,gBAA7B,C,CACA;;AACA,SAASC,EAAE,IAAIC,OAAf,QAA6C,cAA7C;AAEA;AACA;AACA;;AACA,SAASC,UAAT,EAAqBC,WAArB,QAAwC,oBAAxC,C,CAEA;;AACA,MAAMC,mBAA4C,GAAGN,aAAa,CAACO,QAAnE;;AAEA,MAAMC,sBAAsB,GAAG,MAAMJ,UAAU,CAAEE,mBAAF,CAA/C;;AAEA,MAAMG,kBAAkB,GAAKC,CAAF,IAC1B,CAAE,MAAF,EAAU,QAAV,EAAqBC,KAArB,CAA8BC,CAAF,IAAS,OAAOF,CAAC,CAAEE,CAAF,CAAR,KAAkB,WAAvD,CADD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,KAAK,GAAG,MAAM;AAC1B,QAAMC,KAAK,GAAGN,sBAAsB,EAApC;AAEA,QAAMN,EAAE,GAAGG,WAAW,CACrB,CAAE,GAAGU,UAAL,KAA6D;AAC5D,WAAOZ,OAAO,CACb,GAAGY,UAAU,CAACC,GAAX,CAAkBC,GAAF,IAAW;AAC7B,UAAKR,kBAAkB,CAAEQ,GAAF,CAAvB,EAAiC;AAChChB,QAAAA,YAAY,CAAEa,KAAF,EAASG,GAAT,EAAc,KAAd,CAAZ;AACA,eAAQ,GAAGH,KAAK,CAACI,GAAK,IAAID,GAAG,CAACE,IAAM,EAApC;AACA;;AACD,aAAOF,GAAP;AACA,KANE,CADU,CAAd;AASA,GAXoB,EAYrB,CAAEH,KAAF,CAZqB,CAAtB;AAeA,SAAOZ,EAAP;AACA,CAnBM","sourcesContent":["/**\n * External dependencies\n */\n// eslint-disable-next-line no-restricted-imports\nimport type { Context } from 'react';\nimport { CacheProvider, EmotionCache } from '@emotion/react';\nimport type { SerializedStyles } from '@emotion/serialize';\nimport { insertStyles } from '@emotion/utils';\n// eslint-disable-next-line no-restricted-imports\nimport { cx as innerCx, ClassNamesArg } from '@emotion/css';\n\n/**\n * WordPress dependencies\n */\nimport { useContext, useCallback } from '@wordpress/element';\n\n// @ts-ignore Private property\nconst EmotionCacheContext: Context< EmotionCache > = CacheProvider._context;\n\nconst useEmotionCacheContext = () => useContext( EmotionCacheContext );\n\nconst isSerializedStyles = ( o: any ): o is SerializedStyles =>\n\t[ 'name', 'styles' ].every( ( p ) => typeof o[ p ] !== 'undefined' );\n\n/**\n * Retrieve a `cx` function that knows how to handle `SerializedStyles`\n * returned by the `@emotion/react` `css` function in addition to what\n * `cx` normally knows how to handle. It also hooks into the Emotion\n * Cache, allowing `css` calls to work inside iframes.\n *\n * @example\n * import { css } from '@emotion/react';\n *\n * const styles = css`\n * \tcolor: red\n * `;\n *\n * function RedText( { className, ...props } ) {\n * \tconst cx = useCx();\n *\n * \tconst classes = cx(styles, className);\n *\n * \treturn <span className={classes} {...props} />;\n * }\n */\nexport const useCx = () => {\n\tconst cache = useEmotionCacheContext();\n\n\tconst cx = useCallback(\n\t\t( ...classNames: ( ClassNamesArg | SerializedStyles )[] ) => {\n\t\t\treturn innerCx(\n\t\t\t\t...classNames.map( ( arg ) => {\n\t\t\t\t\tif ( isSerializedStyles( arg ) ) {\n\t\t\t\t\t\tinsertStyles( cache, arg, false );\n\t\t\t\t\t\treturn `${ cache.key }-${ arg.name }`;\n\t\t\t\t\t}\n\t\t\t\t\treturn arg;\n\t\t\t\t} )\n\t\t\t);\n\t\t},\n\t\t[ cache ]\n\t);\n\n\treturn cx;\n};\n"]}