/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports
import { CacheProvider } from '@emotion/react';
import { insertStyles } from '@emotion/utils'; // eslint-disable-next-line no-restricted-imports

import { cx as innerCx } from '@emotion/css';
/**
 * WordPress dependencies
 */

import { useContext, useCallback } from '@wordpress/element'; // @ts-ignore Private property

const EmotionCacheContext = CacheProvider._context;

const useEmotionCacheContext = () => useContext(EmotionCacheContext);

const isSerializedStyles = o => ['name', 'styles'].every(p => typeof o[p] !== 'undefined');
/**
 * Retrieve a `cx` function that knows how to handle `SerializedStyles`
 * returned by the `@emotion/react` `css` function in addition to what
 * `cx` normally knows how to handle. It also hooks into the Emotion
 * Cache, allowing `css` calls to work inside iframes.
 *
 * @example
 * import { css } from '@emotion/react';
 *
 * const styles = css`
 * 	color: red
 * `;
 *
 * function RedText( { className, ...props } ) {
 * 	const cx = useCx();
 *
 * 	const classes = cx(styles, className);
 *
 * 	return <span className={classes} {...props} />;
 * }
 */


export const useCx = () => {
  const cache = useEmotionCacheContext();
  const cx = useCallback((...classNames) => {
    return innerCx(...classNames.map(arg => {
      if (isSerializedStyles(arg)) {
        insertStyles(cache, arg, false);
        return `${cache.key}-${arg.name}`;
      }

      return arg;
    }));
  }, [cache]);
  return cx;
};
//# sourceMappingURL=use-cx.js.map