{"version":3,"sources":["@wordpress/data/src/resolvers-cache-middleware.js"],"names":["createResolversCacheMiddleware","registry","reducerKey","next","action","resolvers","select","STORE_NAME","getCachedResolvers","Object","entries","forEach","selectorName","resolversByArgs","resolver","stores","shouldInvalidate","value","args","dispatch","invalidateResolution"],"mappings":";;;;;;;AAGA;;AAKA;;AARA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,8BAA8B,GAAG,CAAEC,QAAF,EAAYC,UAAZ,KAA4B,MAClEC,IADwE,IAElEC,MAAF,IAAc;AAClB,QAAMC,SAAS,GAAGJ,QAAQ,CACxBK,MADgB,CACRC,gBADQ,EAEhBC,kBAFgB,CAEIN,UAFJ,CAAlB;AAGAO,EAAAA,MAAM,CAACC,OAAP,CAAgBL,SAAhB,EAA4BM,OAA5B,CACC,CAAE,CAAEC,YAAF,EAAgBC,eAAhB,CAAF,KAAyC;AACxC,UAAMC,QAAQ,GAAG,iBAAKb,QAAQ,CAACc,MAAd,EAAsB,CACtCb,UADsC,EAEtC,WAFsC,EAGtCU,YAHsC,CAAtB,CAAjB;;AAKA,QAAK,CAAEE,QAAF,IAAc,CAAEA,QAAQ,CAACE,gBAA9B,EAAiD;AAChD;AACA;;AACDH,IAAAA,eAAe,CAACF,OAAhB,CAAyB,CAAEM,KAAF,EAASC,IAAT,KAAmB;AAC3C;AACA;AACA;AACA,UACCD,KAAK,KAAK,KAAV,IACA,CAAEH,QAAQ,CAACE,gBAAT,CAA2BZ,MAA3B,EAAmC,GAAGc,IAAtC,CAFH,EAGE;AACD;AACA,OAT0C,CAW3C;;;AACAjB,MAAAA,QAAQ,CACNkB,QADF,CACYZ,gBADZ,EAEEa,oBAFF,CAEwBlB,UAFxB,EAEoCU,YAFpC,EAEkDM,IAFlD;AAGA,KAfD;AAgBA,GA1BF;AA4BA,SAAOf,IAAI,CAAEC,MAAF,CAAX;AACA,CAnCD;;eAqCeJ,8B","sourcesContent":["/**\n * External dependencies\n */\nimport { get } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { STORE_NAME } from './store/name';\n\n/** @typedef {import('./registry').WPDataRegistry} WPDataRegistry */\n\n/**\n * Creates a middleware handling resolvers cache invalidation.\n *\n * @param {WPDataRegistry} registry   The registry reference for which to create\n *                                    the middleware.\n * @param {string}         reducerKey The namespace for which to create the\n *                                    middleware.\n *\n * @return {Function} Middleware function.\n */\nconst createResolversCacheMiddleware = ( registry, reducerKey ) => () => (\n\tnext\n) => ( action ) => {\n\tconst resolvers = registry\n\t\t.select( STORE_NAME )\n\t\t.getCachedResolvers( reducerKey );\n\tObject.entries( resolvers ).forEach(\n\t\t( [ selectorName, resolversByArgs ] ) => {\n\t\t\tconst resolver = get( registry.stores, [\n\t\t\t\treducerKey,\n\t\t\t\t'resolvers',\n\t\t\t\tselectorName,\n\t\t\t] );\n\t\t\tif ( ! resolver || ! resolver.shouldInvalidate ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresolversByArgs.forEach( ( value, args ) => {\n\t\t\t\t// resolversByArgs is the map Map([ args ] => boolean) storing the cache resolution status for a given selector.\n\t\t\t\t// If the value is false it means this resolver has finished its resolution which means we need to invalidate it,\n\t\t\t\t// if it's true it means it's inflight and the invalidation is not necessary.\n\t\t\t\tif (\n\t\t\t\t\tvalue !== false ||\n\t\t\t\t\t! resolver.shouldInvalidate( action, ...args )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Trigger cache invalidation\n\t\t\t\tregistry\n\t\t\t\t\t.dispatch( STORE_NAME )\n\t\t\t\t\t.invalidateResolution( reducerKey, selectorName, args );\n\t\t\t} );\n\t\t}\n\t);\n\treturn next( action );\n};\n\nexport default createResolversCacheMiddleware;\n"]}