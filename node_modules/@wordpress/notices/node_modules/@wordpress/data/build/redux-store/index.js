"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createReduxStore;

var _redux = require("redux");

var _lodash = require("lodash");

var _turboCombineReducers = _interopRequireDefault(require("turbo-combine-reducers"));

var _equivalentKeyMap = _interopRequireDefault(require("equivalent-key-map"));

var _reduxRoutine = _interopRequireDefault(require("@wordpress/redux-routine"));

var _controls = require("../controls");

var _promiseMiddleware = _interopRequireDefault(require("../promise-middleware"));

var _resolversCacheMiddleware = _interopRequireDefault(require("../resolvers-cache-middleware"));

var _thunkMiddleware = _interopRequireDefault(require("./thunk-middleware"));

var _reducer = _interopRequireDefault(require("./metadata/reducer"));

var metadataSelectors = _interopRequireWildcard(require("./metadata/selectors"));

var metadataActions = _interopRequireWildcard(require("./metadata/actions"));

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('../types').WPDataRegistry} WPDataRegistry */

/** @typedef {import('../types').WPDataStore} WPDataStore */

/** @typedef {import('../types').WPDataReduxStoreConfig} WPDataReduxStoreConfig */

/**
 * Create a cache to track whether resolvers started running or not.
 *
 * @return {Object} Resolvers Cache.
 */
function createResolversCache() {
  const cache = {};
  return {
    isRunning(selectorName, args) {
      return cache[selectorName] && cache[selectorName].get(args);
    },

    clear(selectorName, args) {
      if (cache[selectorName]) {
        cache[selectorName].delete(args);
      }
    },

    markAsRunning(selectorName, args) {
      if (!cache[selectorName]) {
        cache[selectorName] = new _equivalentKeyMap.default();
      }

      cache[selectorName].set(args, true);
    }

  };
}
/**
 * Creates a data store definition for the provided Redux store options containing
 * properties describing reducer, actions, selectors, controls and resolvers.
 *
 * @example
 * ```js
 * import { createReduxStore } from '@wordpress/data';
 *
 * const store = createReduxStore( 'demo', {
 *     reducer: ( state = 'OK' ) => state,
 *     selectors: {
 *         getValue: ( state ) => state,
 *     },
 * } );
 * ```
 *
 * @param {string}                 key     Unique namespace identifier.
 * @param {WPDataReduxStoreConfig} options Registered store options, with properties
 *                                         describing reducer, actions, selectors,
 *                                         and resolvers.
 *
 * @return {WPDataStore} Store Object.
 */


function createReduxStore(key, options) {
  return {
    name: key,
    instantiate: registry => {
      const reducer = options.reducer;
      const thunkArgs = {
        registry,

        get dispatch() {
          return Object.assign(action => store.dispatch(action), getActions());
        },

        get select() {
          return Object.assign(selector => selector(store.__unstableOriginalGetState()), getSelectors());
        },

        get resolveSelect() {
          return getResolveSelectors();
        }

      };
      const store = instantiateReduxStore(key, options, registry, thunkArgs);
      const resolversCache = createResolversCache();
      let resolvers;
      const actions = mapActions({ ...metadataActions,
        ...options.actions
      }, store);
      let selectors = mapSelectors({ ...(0, _lodash.mapValues)(metadataSelectors, selector => (state, ...args) => selector(state.metadata, ...args)),
        ...(0, _lodash.mapValues)(options.selectors, selector => {
          if (selector.isRegistrySelector) {
            selector.registry = registry;
          }

          return (state, ...args) => selector(state.root, ...args);
        })
      }, store);

      if (options.resolvers) {
        const result = mapResolvers(options.resolvers, selectors, store, resolversCache);
        resolvers = result.resolvers;
        selectors = result.selectors;
      }

      const resolveSelectors = mapResolveSelectors(selectors, store);

      const getSelectors = () => selectors;

      const getActions = () => actions;

      const getResolveSelectors = () => resolveSelectors; // We have some modules monkey-patching the store object
      // It's wrong to do so but until we refactor all of our effects to controls
      // We need to keep the same "store" instance here.


      store.__unstableOriginalGetState = store.getState;

      store.getState = () => store.__unstableOriginalGetState().root; // Customize subscribe behavior to call listeners only on effective change,
      // not on every dispatch.


      const subscribe = store && (listener => {
        let lastState = store.__unstableOriginalGetState();

        return store.subscribe(() => {
          const state = store.__unstableOriginalGetState();

          const hasChanged = state !== lastState;
          lastState = state;

          if (hasChanged) {
            listener();
          }
        });
      }); // This can be simplified to just { subscribe, getSelectors, getActions }
      // Once we remove the use function.


      return {
        reducer,
        store,
        actions,
        selectors,
        resolvers,
        getSelectors,
        getResolveSelectors,
        getActions,
        subscribe
      };
    }
  };
}
/**
 * Creates a redux store for a namespace.
 *
 * @param {string}         key       Unique namespace identifier.
 * @param {Object}         options   Registered store options, with properties
 *                                   describing reducer, actions, selectors,
 *                                   and resolvers.
 * @param {WPDataRegistry} registry  Registry reference.
 * @param {Object}         thunkArgs Argument object for the thunk middleware.
 * @return {Object} Newly created redux store.
 */


function instantiateReduxStore(key, options, registry, thunkArgs) {
  const controls = { ...options.controls,
    ..._controls.builtinControls
  };
  const normalizedControls = (0, _lodash.mapValues)(controls, control => control.isRegistryControl ? control(registry) : control);
  const middlewares = [(0, _resolversCacheMiddleware.default)(registry, key), _promiseMiddleware.default, (0, _reduxRoutine.default)(normalizedControls)];

  if (options.__experimentalUseThunks) {
    middlewares.push((0, _thunkMiddleware.default)(thunkArgs));
  }

  const enhancers = [(0, _redux.applyMiddleware)(...middlewares)];

  if (typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {
    enhancers.push(window.__REDUX_DEVTOOLS_EXTENSION__({
      name: key,
      instanceId: key
    }));
  }

  const {
    reducer,
    initialState
  } = options;
  const enhancedReducer = (0, _turboCombineReducers.default)({
    metadata: _reducer.default,
    root: reducer
  });
  return (0, _redux.createStore)(enhancedReducer, {
    root: initialState
  }, (0, _lodash.flowRight)(enhancers));
}
/**
 * Maps selectors to a store.
 *
 * @param {Object} selectors Selectors to register. Keys will be used as the
 *                           public facing API. Selectors will get passed the
 *                           state as first argument.
 * @param {Object} store     The store to which the selectors should be mapped.
 * @return {Object} Selectors mapped to the provided store.
 */


function mapSelectors(selectors, store) {
  const createStateSelector = registrySelector => {
    const selector = function runSelector() {
      // This function is an optimized implementation of:
      //
      //   selector( store.getState(), ...arguments )
      //
      // Where the above would incur an `Array#concat` in its application,
      // the logic here instead efficiently constructs an arguments array via
      // direct assignment.
      const argsLength = arguments.length;
      const args = new Array(argsLength + 1);
      args[0] = store.__unstableOriginalGetState();

      for (let i = 0; i < argsLength; i++) {
        args[i + 1] = arguments[i];
      }

      return registrySelector(...args);
    };

    selector.hasResolver = false;
    return selector;
  };

  return (0, _lodash.mapValues)(selectors, createStateSelector);
}
/**
 * Maps actions to dispatch from a given store.
 *
 * @param {Object} actions Actions to register.
 * @param {Object} store   The redux store to which the actions should be mapped.
 *
 * @return {Object} Actions mapped to the redux store provided.
 */


function mapActions(actions, store) {
  const createBoundAction = action => (...args) => {
    return Promise.resolve(store.dispatch(action(...args)));
  };

  return (0, _lodash.mapValues)(actions, createBoundAction);
}
/**
 * Maps selectors to functions that return a resolution promise for them
 *
 * @param {Object} selectors Selectors to map.
 * @param {Object} store     The redux store the selectors select from.
 *
 * @return {Object} Selectors mapped to their resolution functions.
 */


function mapResolveSelectors(selectors, store) {
  return (0, _lodash.mapValues)((0, _lodash.omit)(selectors, ['getIsResolving', 'hasStartedResolution', 'hasFinishedResolution', 'isResolving', 'getCachedResolvers']), (selector, selectorName) => (...args) => new Promise(resolve => {
    const hasFinished = () => selectors.hasFinishedResolution(selectorName, args);

    const getResult = () => selector.apply(null, args); // trigger the selector (to trigger the resolver)


    const result = getResult();

    if (hasFinished()) {
      return resolve(result);
    }

    const unsubscribe = store.subscribe(() => {
      if (hasFinished()) {
        unsubscribe();
        resolve(getResult());
      }
    });
  }));
}
/**
 * Returns resolvers with matched selectors for a given namespace.
 * Resolvers are side effects invoked once per argument set of a given selector call,
 * used in ensuring that the data needs for the selector are satisfied.
 *
 * @param {Object} resolvers      Resolvers to register.
 * @param {Object} selectors      The current selectors to be modified.
 * @param {Object} store          The redux store to which the resolvers should be mapped.
 * @param {Object} resolversCache Resolvers Cache.
 */


function mapResolvers(resolvers, selectors, store, resolversCache) {
  // The `resolver` can be either a function that does the resolution, or, in more advanced
  // cases, an object with a `fullfill` method and other optional methods like `isFulfilled`.
  // Here we normalize the `resolver` function to an object with `fulfill` method.
  const mappedResolvers = (0, _lodash.mapValues)(resolvers, resolver => {
    if (resolver.fulfill) {
      return resolver;
    }

    return { ...resolver,
      // copy the enumerable properties of the resolver function
      fulfill: resolver // add the fulfill method

    };
  });

  const mapSelector = (selector, selectorName) => {
    const resolver = resolvers[selectorName];

    if (!resolver) {
      selector.hasResolver = false;
      return selector;
    }

    const selectorResolver = (...args) => {
      async function fulfillSelector() {
        const state = store.getState();

        if (resolversCache.isRunning(selectorName, args) || typeof resolver.isFulfilled === 'function' && resolver.isFulfilled(state, ...args)) {
          return;
        }

        const {
          metadata
        } = store.__unstableOriginalGetState();

        if (metadataSelectors.hasStartedResolution(metadata, selectorName, args)) {
          return;
        }

        resolversCache.markAsRunning(selectorName, args);
        setTimeout(async () => {
          resolversCache.clear(selectorName, args);
          store.dispatch(metadataActions.startResolution(selectorName, args));
          await fulfillResolver(store, mappedResolvers, selectorName, ...args);
          store.dispatch(metadataActions.finishResolution(selectorName, args));
        });
      }

      fulfillSelector(...args);
      return selector(...args);
    };

    selectorResolver.hasResolver = true;
    return selectorResolver;
  };

  return {
    resolvers: mappedResolvers,
    selectors: (0, _lodash.mapValues)(selectors, mapSelector)
  };
}
/**
 * Calls a resolver given arguments
 *
 * @param {Object} store        Store reference, for fulfilling via resolvers
 * @param {Object} resolvers    Store Resolvers
 * @param {string} selectorName Selector name to fulfill.
 * @param {Array}  args         Selector Arguments.
 */


async function fulfillResolver(store, resolvers, selectorName, ...args) {
  const resolver = (0, _lodash.get)(resolvers, [selectorName]);

  if (!resolver) {
    return;
  }

  const action = resolver.fulfill(...args);

  if (action) {
    await store.dispatch(action);
  }
}
//# sourceMappingURL=index.js.map