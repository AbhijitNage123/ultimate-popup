{"version":3,"sources":["@wordpress/rich-text/src/apply-format.js"],"names":["replace","array","index","value","slice","applyFormat","format","startIndex","start","endIndex","end","formats","activeFormats","newFormats","startFormat","type","indexOf","position","Infinity","filter","length","splice"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], {\n\t\t\ttype: format.type,\n\t\t} );\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...reject( activeFormats, { type: format.type } ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n"]}