{"version":3,"sources":["@wordpress/rich-text/src/remove-format.js"],"names":["removeFormat","value","formatType","startIndex","start","endIndex","end","formats","activeFormats","newFormats","slice","format","type","filterFormats","i","index","filter","length"],"mappings":";;;;;;;AAIA;;AAMA;;AAVA;AACA;AACA;;AAIA;AACA;AACA;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,YAAT,CACNC,KADM,EAENC,UAFM,EAGNC,UAAU,GAAGF,KAAK,CAACG,KAHb,EAINC,QAAQ,GAAGJ,KAAK,CAACK,GAJX,EAKL;AACD,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAA6BP,KAAnC;AACA,QAAMQ,UAAU,GAAGF,OAAO,CAACG,KAAR,EAAnB,CAFC,CAID;AACA;;AACA,MAAKP,UAAU,KAAKE,QAApB,EAA+B;AAC9B,UAAMM,MAAM,GAAG,kBAAMF,UAAU,CAAEN,UAAF,CAAhB,EAAgC;AAAES,MAAAA,IAAI,EAAEV;AAAR,KAAhC,CAAf;;AAEA,QAAKS,MAAL,EAAc;AACb,aAAQ,kBAAMF,UAAU,CAAEN,UAAF,CAAhB,EAAgCQ,MAAhC,CAAR,EAAmD;AAClDE,QAAAA,aAAa,CAAEJ,UAAF,EAAcN,UAAd,EAA0BD,UAA1B,CAAb;AACAC,QAAAA,UAAU;AACV;;AAEDE,MAAAA,QAAQ;;AAER,aAAQ,kBAAMI,UAAU,CAAEJ,QAAF,CAAhB,EAA8BM,MAA9B,CAAR,EAAiD;AAChDE,QAAAA,aAAa,CAAEJ,UAAF,EAAcJ,QAAd,EAAwBH,UAAxB,CAAb;AACAG,QAAAA,QAAQ;AACR;AACD;AACD,GAhBD,MAgBO;AACN,SAAM,IAAIS,CAAC,GAAGX,UAAd,EAA0BW,CAAC,GAAGT,QAA9B,EAAwCS,CAAC,EAAzC,EAA8C;AAC7C,UAAKL,UAAU,CAAEK,CAAF,CAAf,EAAuB;AACtBD,QAAAA,aAAa,CAAEJ,UAAF,EAAcK,CAAd,EAAiBZ,UAAjB,CAAb;AACA;AACD;AACD;;AAED,SAAO,wCAAkB,EACxB,GAAGD,KADqB;AAExBM,IAAAA,OAAO,EAAEE,UAFe;AAGxBD,IAAAA,aAAa,EAAE,oBAAQA,aAAR,EAAuB;AAAEI,MAAAA,IAAI,EAAEV;AAAR,KAAvB;AAHS,GAAlB,CAAP;AAKA;;AAED,SAASW,aAAT,CAAwBN,OAAxB,EAAiCQ,KAAjC,EAAwCb,UAAxC,EAAqD;AACpD,QAAMO,UAAU,GAAGF,OAAO,CAAEQ,KAAF,CAAP,CAAiBC,MAAjB,CAClB,CAAE;AAAEJ,IAAAA;AAAF,GAAF,KAAgBA,IAAI,KAAKV,UADP,CAAnB;;AAIA,MAAKO,UAAU,CAACQ,MAAhB,EAAyB;AACxBV,IAAAA,OAAO,CAAEQ,KAAF,CAAP,GAAmBN,UAAnB;AACA,GAFD,MAEO;AACN,WAAOF,OAAO,CAAEQ,KAAF,CAAd;AACA;AACD","sourcesContent":["/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function removeFormat(\n\tvalue,\n\tformatType,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = find( newFormats[ startIndex ], { type: formatType } );\n\n\t\tif ( format ) {\n\t\t\twhile ( find( newFormats[ startIndex ], format ) ) {\n\t\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile ( find( newFormats[ endIndex ], format ) ) {\n\t\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\tactiveFormats: reject( activeFormats, { type: formatType } ),\n\t} );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter(\n\t\t( { type } ) => type !== formatType\n\t);\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n"]}