{"version":3,"sources":["@wordpress/rich-text/src/indent-list-items.js"],"names":["getTargetLevelLineIndex","text","replacements","lineIndex","startFormats","index","LINE_SEPARATOR","formatsAtIndex","length","indentListItems","value","rootFormat","previousLineIndex","end","newFormats","slice","targetLevelLineIndex","targetFormats","concat","lastformat"],"mappings":";;;;;;;AAIA;;AACA;;AACA;;AANA;AACA;AACA;;AAMA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,uBAAT,CAAkC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAlC,EAA0DC,SAA1D,EAAsE;AACrE,QAAMC,YAAY,GAAGF,YAAY,CAAEC,SAAF,CAAZ,IAA6B,EAAlD;AAEA,MAAIE,KAAK,GAAGF,SAAZ;;AAEA,SAAQE,KAAK,MAAM,CAAnB,EAAuB;AACtB,QAAKJ,IAAI,CAAEI,KAAF,CAAJ,KAAkBC,iCAAvB,EAAwC;AACvC;AACA;;AAED,UAAMC,cAAc,GAAGL,YAAY,CAAEG,KAAF,CAAZ,IAAyB,EAAhD,CALsB,CAOtB;AACA;;AACA,QAAKE,cAAc,CAACC,MAAf,KAA0BJ,YAAY,CAACI,MAAb,GAAsB,CAArD,EAAyD;AACxD,aAAOH,KAAP;AACA,KAFD,MAEO,IAAKE,cAAc,CAACC,MAAf,IAAyBJ,YAAY,CAACI,MAA3C,EAAoD;AAC1D;AACA;AACD;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASC,eAAT,CAA0BC,KAA1B,EAAiCC,UAAjC,EAA8C;AACpD,MAAK,CAAE,4CAAoBD,KAApB,CAAP,EAAqC;AACpC,WAAOA,KAAP;AACA;;AAED,QAAMP,SAAS,GAAG,gCAAcO,KAAd,CAAlB;AACA,QAAME,iBAAiB,GAAG,gCAAcF,KAAd,EAAqBP,SAArB,CAA1B;AACA,QAAM;AAAEF,IAAAA,IAAF;AAAQC,IAAAA,YAAR;AAAsBW,IAAAA;AAAtB,MAA8BH,KAApC;AACA,QAAMI,UAAU,GAAGZ,YAAY,CAACa,KAAb,EAAnB;AACA,QAAMC,oBAAoB,GAAGhB,uBAAuB,CAAEU,KAAF,EAASP,SAAT,CAApD;;AAEA,OAAM,IAAIE,KAAK,GAAGF,SAAlB,EAA6BE,KAAK,GAAGQ,GAArC,EAA0CR,KAAK,EAA/C,EAAoD;AACnD,QAAKJ,IAAI,CAAEI,KAAF,CAAJ,KAAkBC,iCAAvB,EAAwC;AACvC;AACA,KAHkD,CAKnD;AACA;;;AACA,QAAKU,oBAAL,EAA4B;AAC3B,YAAMC,aAAa,GAAGf,YAAY,CAAEc,oBAAF,CAAZ,IAAwC,EAA9D;AACAF,MAAAA,UAAU,CAAET,KAAF,CAAV,GAAsBY,aAAa,CAACC,MAAd,CACrB,CAAEJ,UAAU,CAAET,KAAF,CAAV,IAAuB,EAAzB,EAA8BU,KAA9B,CAAqCE,aAAa,CAACT,MAAd,GAAuB,CAA5D,CADqB,CAAtB;AAGA,KALD,MAKO;AACN,YAAMS,aAAa,GAAGf,YAAY,CAAEU,iBAAF,CAAZ,IAAqC,EAA3D;AACA,YAAMO,UAAU,GACfF,aAAa,CAAEA,aAAa,CAACT,MAAd,GAAuB,CAAzB,CAAb,IAA6CG,UAD9C;AAGAG,MAAAA,UAAU,CAAET,KAAF,CAAV,GAAsBY,aAAa,CAACC,MAAd,CACrB,CAAEC,UAAF,CADqB,EAErB,CAAEL,UAAU,CAAET,KAAF,CAAV,IAAuB,EAAzB,EAA8BU,KAA9B,CAAqCE,aAAa,CAACT,MAAnD,CAFqB,CAAtB;AAIA;AACD;;AAED,SAAO,EACN,GAAGE,KADG;AAENR,IAAAA,YAAY,EAAEY;AAFR,GAAP;AAIA","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { canIndentListItems } from './can-indent-list-items';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the line index of the first previous list item with higher indentation.\n *\n * @param {RichTextValue} value     Value to search.\n * @param {number}        lineIndex Line index of the list item to compare\n *                                  with.\n *\n * @return {number|void} The line index.\n */\nfunction getTargetLevelLineIndex( { text, replacements }, lineIndex ) {\n\tconst startFormats = replacements[ lineIndex ] || [];\n\n\tlet index = lineIndex;\n\n\twhile ( index-- >= 0 ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\t// Return the first line index that is one level higher. If the level is\n\t\t// lower or equal, there is no result.\n\t\tif ( formatsAtIndex.length === startFormats.length + 1 ) {\n\t\t\treturn index;\n\t\t} else if ( formatsAtIndex.length <= startFormats.length ) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/**\n * Indents any selected list items if possible.\n *\n * @param {RichTextValue}  value      Value to change.\n * @param {RichTextFormat} rootFormat Root format.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function indentListItems( value, rootFormat ) {\n\tif ( ! canIndentListItems( value ) ) {\n\t\treturn value;\n\t}\n\n\tconst lineIndex = getLineIndex( value );\n\tconst previousLineIndex = getLineIndex( value, lineIndex );\n\tconst { text, replacements, end } = value;\n\tconst newFormats = replacements.slice();\n\tconst targetLevelLineIndex = getTargetLevelLineIndex( value, lineIndex );\n\n\tfor ( let index = lineIndex; index < end; index++ ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get the previous list, and if there's a child list, take over the\n\t\t// formats. If not, duplicate the last level and create a new level.\n\t\tif ( targetLevelLineIndex ) {\n\t\t\tconst targetFormats = replacements[ targetLevelLineIndex ] || [];\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length - 1 )\n\t\t\t);\n\t\t} else {\n\t\t\tconst targetFormats = replacements[ previousLineIndex ] || [];\n\t\t\tconst lastformat =\n\t\t\t\ttargetFormats[ targetFormats.length - 1 ] || rootFormat;\n\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t[ lastformat ],\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length )\n\t\t\t);\n\t\t}\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newFormats,\n\t};\n}\n"]}