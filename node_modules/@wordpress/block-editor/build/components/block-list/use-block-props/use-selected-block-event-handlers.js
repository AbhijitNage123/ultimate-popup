"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEventHandlers = useEventHandlers;

var _dom = require("@wordpress/dom");

var _keycodes = require("@wordpress/keycodes");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _store = require("../../../store");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Adds block behaviour:
 *   - Removes the block on BACKSPACE.
 *   - Inserts a default block on ENTER.
 *   - Disables dragging of block contents.
 *
 * @param {string} clientId Block client ID.
 */
function useEventHandlers(clientId) {
  const isSelected = (0, _data.useSelect)(select => select(_store.store).isBlockSelected(clientId), [clientId]);
  const {
    getBlockRootClientId,
    getBlockIndex
  } = (0, _data.useSelect)(_store.store);
  const {
    insertDefaultBlock,
    removeBlock
  } = (0, _data.useDispatch)(_store.store);
  return (0, _compose.useRefEffect)(node => {
    if (!isSelected) {
      return;
    }
    /**
     * Interprets keydown event intent to remove or insert after block if
     * key event occurs on wrapper node. This can occur when the block has
     * no text fields of its own, particularly after initial insertion, to
     * allow for easy deletion and continuous writing flow to add additional
     * content.
     *
     * @param {KeyboardEvent} event Keydown event.
     */


    function onKeyDown(event) {
      const {
        keyCode,
        target
      } = event;

      if (keyCode !== _keycodes.ENTER && keyCode !== _keycodes.BACKSPACE && keyCode !== _keycodes.DELETE) {
        return;
      }

      if (target !== node || (0, _dom.isTextField)(target)) {
        return;
      }

      event.preventDefault();

      if (keyCode === _keycodes.ENTER) {
        insertDefaultBlock({}, getBlockRootClientId(clientId), getBlockIndex(clientId) + 1);
      } else {
        removeBlock(clientId);
      }
    }
    /**
     * Prevents default dragging behavior within a block. To do: we must
     * handle this in the future and clean up the drag target.
     *
     * @param {DragEvent} event Drag event.
     */


    function onDragStart(event) {
      event.preventDefault();
    }

    node.addEventListener('keydown', onKeyDown);
    node.addEventListener('dragstart', onDragStart);
    return () => {
      node.removeEventListener('keydown', onKeyDown);
      node.removeEventListener('dragstart', onDragStart);
    };
  }, [clientId, isSelected, getBlockRootClientId, getBlockIndex, insertDefaultBlock, removeBlock]);
}
//# sourceMappingURL=use-selected-block-event-handlers.js.map