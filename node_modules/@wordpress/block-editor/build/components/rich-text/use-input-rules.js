"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInputRules = useInputRules;

var _element = require("@wordpress/element");

var _compose = require("@wordpress/compose");

var _richText = require("@wordpress/rich-text");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _store = require("../../store");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function useInputRules(props) {
  const {
    __unstableMarkLastChangeAsPersistent,
    __unstableMarkAutomaticChange
  } = (0, _data.useDispatch)(_store.store);
  const propsRef = (0, _element.useRef)(props);
  propsRef.current = props;
  return (0, _compose.useRefEffect)(element => {
    function inputRule() {
      const {
        value,
        onReplace
      } = propsRef.current;

      if (!onReplace) {
        return;
      }

      const {
        start,
        text
      } = value;
      const characterBefore = text.slice(start - 1, start); // The character right before the caret must be a plain space.

      if (characterBefore !== ' ') {
        return;
      }

      const trimmedTextBefore = text.slice(0, start).trim();
      const prefixTransforms = (0, _blocks.getBlockTransforms)('from').filter(({
        type
      }) => type === 'prefix');
      const transformation = (0, _blocks.findTransform)(prefixTransforms, ({
        prefix
      }) => {
        return trimmedTextBefore === prefix;
      });

      if (!transformation) {
        return;
      }

      const content = (0, _richText.toHTMLString)({
        value: (0, _richText.slice)(value, start, text.length)
      });
      const block = transformation.transform(content);
      onReplace([block]);

      __unstableMarkAutomaticChange();
    }

    function onInput(event) {
      const {
        inputType,
        type
      } = event;
      const {
        value,
        onChange,
        __unstableAllowPrefixTransformations,
        formatTypes
      } = propsRef.current; // Only run input rules when inserting text.

      if (inputType !== 'insertText' && type !== 'compositionend') {
        return;
      }

      if (__unstableAllowPrefixTransformations && inputRule) {
        inputRule();
      }

      const transformed = formatTypes.reduce((accumlator, {
        __unstableInputRule
      }) => {
        if (__unstableInputRule) {
          accumlator = __unstableInputRule(accumlator);
        }

        return accumlator;
      }, value);

      if (transformed !== value) {
        __unstableMarkLastChangeAsPersistent();

        onChange({ ...transformed,
          activeFormats: value.activeFormats
        });

        __unstableMarkAutomaticChange();
      }
    }

    element.addEventListener('input', onInput);
    element.addEventListener('compositionend', onInput);
    return () => {
      element.removeEventListener('input', onInput);
      element.removeEventListener('compositionend', onInput);
    };
  }, []);
}
//# sourceMappingURL=use-input-rules.js.map