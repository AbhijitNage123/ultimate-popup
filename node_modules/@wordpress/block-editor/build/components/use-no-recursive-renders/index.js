"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useNoRecursiveRenders;

var _element = require("@wordpress/element");

var _context = require("../block-edit/context");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
const RenderedRefsContext = (0, _element.createContext)({});
/**
 * Immutably adds an unique identifier to a set scoped for a given block type.
 *
 * @param {Object} renderedBlocks Rendered blocks grouped by block name
 * @param {string} blockName      Name of the block.
 * @param {*}      uniqueId       Any value that acts as a unique identifier for a block instance.
 *
 * @return {Object} The list of rendered blocks grouped by block name.
 */

function addToBlockType(renderedBlocks, blockName, uniqueId) {
  const result = { ...renderedBlocks,
    [blockName]: renderedBlocks[blockName] ? new Set(renderedBlocks[blockName]) : new Set()
  };
  result[blockName].add(uniqueId);
  return result;
}
/**
 * A React hook for keeping track of blocks previously rendered up in the block
 * tree. Blocks susceptible to recursion can use this hook in their `Edit`
 * function to prevent said recursion.
 *
 * @param {*}      uniqueId  Any value that acts as a unique identifier for a block instance.
 * @param {string} blockName Optional block name.
 *
 * @return {[boolean, Function]} A tuple of:
 *                               - a boolean describing whether the provided id
 *                                 has already been rendered;
 *                               - a React context provider to be used to wrap
 *                                 other elements.
 */


function useNoRecursiveRenders(uniqueId, blockName = '') {
  var _previouslyRenderedBl;

  const previouslyRenderedBlocks = (0, _element.useContext)(RenderedRefsContext);
  const {
    name
  } = (0, _context.useBlockEditContext)();
  blockName = blockName || name;
  const hasAlreadyRendered = Boolean((_previouslyRenderedBl = previouslyRenderedBlocks[blockName]) === null || _previouslyRenderedBl === void 0 ? void 0 : _previouslyRenderedBl.has(uniqueId));
  const newRenderedBlocks = (0, _element.useMemo)(() => addToBlockType(previouslyRenderedBlocks, blockName, uniqueId), [previouslyRenderedBlocks, blockName, uniqueId]);
  const Provider = (0, _element.useCallback)(({
    children
  }) => (0, _element.createElement)(RenderedRefsContext.Provider, {
    value: newRenderedBlocks
  }, children), [newRenderedBlocks]);
  return [hasAlreadyRendered, Provider];
}
//# sourceMappingURL=index.js.map