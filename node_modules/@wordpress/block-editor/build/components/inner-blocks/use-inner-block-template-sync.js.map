{"version":3,"sources":["@wordpress/block-editor/src/components/inner-blocks/use-inner-block-template-sync.js"],"names":["useInnerBlockTemplateSync","clientId","template","templateLock","templateInsertUpdatesSelection","getSelectedBlocksInitialCaretPosition","blockEditorStore","replaceInnerBlocks","innerBlocks","select","getBlocks","existingTemplate","length","hasTemplateChanged","current","nextBlocks"],"mappings":";;;;;;;AAGA;;AAKA;;AACA;;AACA;;AAKA;;AAfA;AACA;AACA;;AAGA;AACA;AACA;;AAKA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,yBAAT,CACdC,QADc,EAEdC,QAFc,EAGdC,YAHc,EAIdC,8BAJc,EAKb;AACD,QAAM;AAAEC,IAAAA;AAAF,MAA4C,qBACjDC,YADiD,CAAlD;AAGA,QAAM;AAAEC,IAAAA;AAAF,MAAyB,uBAAaD,YAAb,CAA/B;AACA,QAAME,WAAW,GAAG,qBACjBC,MAAF,IAAcA,MAAM,CAAEH,YAAF,CAAN,CAA2BI,SAA3B,CAAsCT,QAAtC,CADK,EAEnB,CAAEA,QAAF,CAFmB,CAApB,CALC,CAUD;;AACA,QAAMU,gBAAgB,GAAG,qBAAQ,IAAR,CAAzB;AACA,gCAAiB,MAAM;AACtB;AACA;AACA,QAAKH,WAAW,CAACI,MAAZ,KAAuB,CAAvB,IAA4BT,YAAY,KAAK,KAAlD,EAA0D;AACzD,YAAMU,kBAAkB,GAAG,CAAE,qBAC5BX,QAD4B,EAE5BS,gBAAgB,CAACG,OAFW,CAA7B;;AAIA,UAAKD,kBAAL,EAA0B;AACzBF,QAAAA,gBAAgB,CAACG,OAAjB,GAA2BZ,QAA3B;AACA,cAAMa,UAAU,GAAG,2CAClBP,WADkB,EAElBN,QAFkB,CAAnB;;AAIA,YAAK,CAAE,qBAASa,UAAT,EAAqBP,WAArB,CAAP,EAA4C;AAC3CD,UAAAA,kBAAkB,CACjBN,QADiB,EAEjBc,UAFiB,EAGjBP,WAAW,CAACI,MAAZ,KAAuB,CAAvB,IACCR,8BADD,IAECW,UAAU,CAACH,MAAX,KAAsB,CALN,EAMjB;AACA;AACA;AACA;AACAP,UAAAA,qCAAqC,EAVpB,CAAlB;AAYA;AACD;AACD;AACD,GA9BD,EA8BG,CAAEG,WAAF,EAAeN,QAAf,EAAyBC,YAAzB,EAAuCF,QAAvC,CA9BH;AA+BA","sourcesContent":["/**\n * External dependencies\n */\nimport { isEqual } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { useRef, useLayoutEffect } from '@wordpress/element';\nimport { useSelect, useDispatch } from '@wordpress/data';\nimport { synchronizeBlocksWithTemplate } from '@wordpress/blocks';\n\n/**\n * Internal dependencies\n */\nimport { store as blockEditorStore } from '../../store';\n\n/**\n * This hook makes sure that a block's inner blocks stay in sync with the given\n * block \"template\". The template is a block hierarchy to which inner blocks must\n * conform. If the blocks get \"out of sync\" with the template and the template\n * is meant to be locked (e.g. templateLock = \"all\"), then we replace the inner\n * blocks with the correct value after synchronizing it with the template.\n *\n * @param {string}  clientId                       The block client ID.\n * @param {Object}  template                       The template to match.\n * @param {string}  templateLock                   The template lock state for the inner blocks. For\n *                                                 example, if the template lock is set to \"all\",\n *                                                 then the inner blocks will stay in sync with the\n *                                                 template. If not defined or set to false, then\n *                                                 the inner blocks will not be synchronized with\n *                                                 the given template.\n * @param {boolean} templateInsertUpdatesSelection Whether or not to update the\n *                                                 block-editor selection state when inner blocks\n *                                                 are replaced after template synchronization.\n */\nexport default function useInnerBlockTemplateSync(\n\tclientId,\n\ttemplate,\n\ttemplateLock,\n\ttemplateInsertUpdatesSelection\n) {\n\tconst { getSelectedBlocksInitialCaretPosition } = useSelect(\n\t\tblockEditorStore\n\t);\n\tconst { replaceInnerBlocks } = useDispatch( blockEditorStore );\n\tconst innerBlocks = useSelect(\n\t\t( select ) => select( blockEditorStore ).getBlocks( clientId ),\n\t\t[ clientId ]\n\t);\n\n\t// Maintain a reference to the previous value so we can do a deep equality check.\n\tconst existingTemplate = useRef( null );\n\tuseLayoutEffect( () => {\n\t\t// Only synchronize innerBlocks with template if innerBlocks are empty or\n\t\t// a locking all exists directly on the block.\n\t\tif ( innerBlocks.length === 0 || templateLock === 'all' ) {\n\t\t\tconst hasTemplateChanged = ! isEqual(\n\t\t\t\ttemplate,\n\t\t\t\texistingTemplate.current\n\t\t\t);\n\t\t\tif ( hasTemplateChanged ) {\n\t\t\t\texistingTemplate.current = template;\n\t\t\t\tconst nextBlocks = synchronizeBlocksWithTemplate(\n\t\t\t\t\tinnerBlocks,\n\t\t\t\t\ttemplate\n\t\t\t\t);\n\t\t\t\tif ( ! isEqual( nextBlocks, innerBlocks ) ) {\n\t\t\t\t\treplaceInnerBlocks(\n\t\t\t\t\t\tclientId,\n\t\t\t\t\t\tnextBlocks,\n\t\t\t\t\t\tinnerBlocks.length === 0 &&\n\t\t\t\t\t\t\ttemplateInsertUpdatesSelection &&\n\t\t\t\t\t\t\tnextBlocks.length !== 0,\n\t\t\t\t\t\t// This ensures the \"initialPosition\" doesn't change when applying the template\n\t\t\t\t\t\t// If we're supposed to focus the block, we'll focus the first inner block\n\t\t\t\t\t\t// otherwise, we won't apply any auto-focus.\n\t\t\t\t\t\t// This ensures for instance that the focus stays in the inserter when inserting the \"buttons\" block.\n\t\t\t\t\t\tgetSelectedBlocksInitialCaretPosition()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, [ innerBlocks, template, templateLock, clientId ] );\n}\n"]}