{"version":3,"sources":["@wordpress/block-editor/src/components/writing-flow/use-arrow-nav.js"],"names":["find","reverse","computeCaretRect","focus","isHorizontalEdge","isVerticalEdge","placeCaretAtHorizontalEdge","placeCaretAtVerticalEdge","isRTL","UP","DOWN","LEFT","RIGHT","useSelect","useDispatch","useRefEffect","isInSameBlock","store","blockEditorStore","isNavigationCandidate","element","keyCode","hasModifier","isVertical","tagName","getClosestTabbable","target","isReverse","containerElement","onlyVertical","focusableNodes","focusable","slice","indexOf","targetRect","getBoundingClientRect","isTabCandidate","node","tabbable","isTabbableIndex","isContentEditable","contentEditable","nodeRect","left","right","useArrowNav","getSelectedBlockClientId","getMultiSelectedBlocksStartClientId","getMultiSelectedBlocksEndClientId","getPreviousBlockClientId","getNextBlockClientId","getFirstMultiSelectedBlockClientId","getLastMultiSelectedBlockClientId","getSettings","hasMultiSelection","multiSelect","selectBlock","verticalRect","onMouseDown","expandSelection","selectedBlockClientId","selectionStartClientId","selectionEndClientId","selectionBeforeEndClientId","selectionAfterEndClientId","nextSelectionEndClientId","moveSelection","selectedFirstClientId","selectedLastClientId","focusedBlockClientId","isTabbableEdge","closestTabbable","onKeyDown","event","isUp","isDown","isLeft","isRight","isHorizontal","isNav","isShift","shiftKey","ctrlKey","altKey","metaKey","isNavEdge","ownerDocument","defaultView","action","preventDefault","defaultPrevented","isReverseDir","keepCaretInsideBlock","getSelection","isCollapsed","addEventListener","removeEventListener"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { find, reverse } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tcomputeCaretRect,\n\tfocus,\n\tisHorizontalEdge,\n\tisVerticalEdge,\n\tplaceCaretAtHorizontalEdge,\n\tplaceCaretAtVerticalEdge,\n\tisRTL,\n} from '@wordpress/dom';\nimport { UP, DOWN, LEFT, RIGHT } from '@wordpress/keycodes';\nimport { useSelect, useDispatch } from '@wordpress/data';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { isInSameBlock } from '../../utils/dom';\nimport { store as blockEditorStore } from '../../store';\n\n/**\n * Returns true if the element should consider edge navigation upon a keyboard\n * event of the given directional key code, or false otherwise.\n *\n * @param {Element} element     HTML element to test.\n * @param {number}  keyCode     KeyboardEvent keyCode to test.\n * @param {boolean} hasModifier Whether a modifier is pressed.\n *\n * @return {boolean} Whether element should consider edge navigation.\n */\nexport function isNavigationCandidate( element, keyCode, hasModifier ) {\n\tconst isVertical = keyCode === UP || keyCode === DOWN;\n\n\t// Currently, all elements support unmodified vertical navigation.\n\tif ( isVertical && ! hasModifier ) {\n\t\treturn true;\n\t}\n\n\t// Native inputs should not navigate horizontally.\n\tconst { tagName } = element;\n\treturn tagName !== 'INPUT' && tagName !== 'TEXTAREA';\n}\n\n/**\n * Returns the optimal tab target from the given focused element in the desired\n * direction. A preference is made toward text fields, falling back to the block\n * focus stop if no other candidates exist for the block.\n *\n * @param {Element} target           Currently focused text field.\n * @param {boolean} isReverse        True if considering as the first field.\n * @param {Element} containerElement Element containing all blocks.\n * @param {boolean} onlyVertical     Whether to only consider tabbable elements\n *                                   that are visually above or under the\n *                                   target.\n *\n * @return {?Element} Optimal tab target, if one exists.\n */\nexport function getClosestTabbable(\n\ttarget,\n\tisReverse,\n\tcontainerElement,\n\tonlyVertical\n) {\n\t// Since the current focus target is not guaranteed to be a text field, find\n\t// all focusables. Tabbability is considered later.\n\tlet focusableNodes = focus.focusable.find( containerElement );\n\n\tif ( isReverse ) {\n\t\tfocusableNodes = reverse( focusableNodes );\n\t}\n\n\t// Consider as candidates those focusables after the current target. It's\n\t// assumed this can only be reached if the target is focusable (on its\n\t// keydown event), so no need to verify it exists in the set.\n\tfocusableNodes = focusableNodes.slice(\n\t\tfocusableNodes.indexOf( target ) + 1\n\t);\n\n\tlet targetRect;\n\n\tif ( onlyVertical ) {\n\t\ttargetRect = target.getBoundingClientRect();\n\t}\n\n\tfunction isTabCandidate( node ) {\n\t\t// Not a candidate if the node is not tabbable.\n\t\tif ( ! focus.tabbable.isTabbableIndex( node ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Skip focusable elements such as links within content editable nodes.\n\t\tif ( node.isContentEditable && node.contentEditable !== 'true' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( onlyVertical ) {\n\t\t\tconst nodeRect = node.getBoundingClientRect();\n\n\t\t\tif (\n\t\t\t\tnodeRect.left >= targetRect.right ||\n\t\t\t\tnodeRect.right <= targetRect.left\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn find( focusableNodes, isTabCandidate );\n}\n\nexport default function useArrowNav() {\n\tconst {\n\t\tgetSelectedBlockClientId,\n\t\tgetMultiSelectedBlocksStartClientId,\n\t\tgetMultiSelectedBlocksEndClientId,\n\t\tgetPreviousBlockClientId,\n\t\tgetNextBlockClientId,\n\t\tgetFirstMultiSelectedBlockClientId,\n\t\tgetLastMultiSelectedBlockClientId,\n\t\tgetSettings,\n\t\thasMultiSelection,\n\t} = useSelect( blockEditorStore );\n\tconst { multiSelect, selectBlock } = useDispatch( blockEditorStore );\n\treturn useRefEffect( ( node ) => {\n\t\t// Here a DOMRect is stored while moving the caret vertically so\n\t\t// vertical position of the start position can be restored. This is to\n\t\t// recreate browser behaviour across blocks.\n\t\tlet verticalRect;\n\n\t\tfunction onMouseDown() {\n\t\t\tverticalRect = null;\n\t\t}\n\n\t\tfunction expandSelection( isReverse ) {\n\t\t\tconst selectedBlockClientId = getSelectedBlockClientId();\n\t\t\tconst selectionStartClientId = getMultiSelectedBlocksStartClientId();\n\t\t\tconst selectionEndClientId = getMultiSelectedBlocksEndClientId();\n\t\t\tconst selectionBeforeEndClientId = getPreviousBlockClientId(\n\t\t\t\tselectionEndClientId || selectedBlockClientId\n\t\t\t);\n\t\t\tconst selectionAfterEndClientId = getNextBlockClientId(\n\t\t\t\tselectionEndClientId || selectedBlockClientId\n\t\t\t);\n\t\t\tconst nextSelectionEndClientId = isReverse\n\t\t\t\t? selectionBeforeEndClientId\n\t\t\t\t: selectionAfterEndClientId;\n\n\t\t\tif ( nextSelectionEndClientId ) {\n\t\t\t\tif ( selectionStartClientId === nextSelectionEndClientId ) {\n\t\t\t\t\tselectBlock( nextSelectionEndClientId );\n\t\t\t\t} else {\n\t\t\t\t\tmultiSelect(\n\t\t\t\t\t\tselectionStartClientId || selectedBlockClientId,\n\t\t\t\t\t\tnextSelectionEndClientId\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction moveSelection( isReverse ) {\n\t\t\tconst selectedFirstClientId = getFirstMultiSelectedBlockClientId();\n\t\t\tconst selectedLastClientId = getLastMultiSelectedBlockClientId();\n\t\t\tconst focusedBlockClientId = isReverse\n\t\t\t\t? selectedFirstClientId\n\t\t\t\t: selectedLastClientId;\n\n\t\t\tif ( focusedBlockClientId ) {\n\t\t\t\tselectBlock( focusedBlockClientId );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns true if the given target field is the last in its block which\n\t\t * can be considered for tab transition. For example, in a block with\n\t\t * two text fields, this would return true when reversing from the first\n\t\t * of the two fields, but false when reversing from the second.\n\t\t *\n\t\t * @param {Element} target    Currently focused text field.\n\t\t * @param {boolean} isReverse True if considering as the first field.\n\t\t *\n\t\t * @return {boolean} Whether field is at edge for tab transition.\n\t\t */\n\t\tfunction isTabbableEdge( target, isReverse ) {\n\t\t\tconst closestTabbable = getClosestTabbable(\n\t\t\t\ttarget,\n\t\t\t\tisReverse,\n\t\t\t\tnode\n\t\t\t);\n\t\t\treturn (\n\t\t\t\t! closestTabbable || ! isInSameBlock( target, closestTabbable )\n\t\t\t);\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\t\t\tconst { keyCode, target } = event;\n\t\t\tconst isUp = keyCode === UP;\n\t\t\tconst isDown = keyCode === DOWN;\n\t\t\tconst isLeft = keyCode === LEFT;\n\t\t\tconst isRight = keyCode === RIGHT;\n\t\t\tconst isReverse = isUp || isLeft;\n\t\t\tconst isHorizontal = isLeft || isRight;\n\t\t\tconst isVertical = isUp || isDown;\n\t\t\tconst isNav = isHorizontal || isVertical;\n\t\t\tconst isShift = event.shiftKey;\n\t\t\tconst hasModifier =\n\t\t\t\tisShift || event.ctrlKey || event.altKey || event.metaKey;\n\t\t\tconst isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;\n\t\t\tconst { ownerDocument } = node;\n\t\t\tconst { defaultView } = ownerDocument;\n\n\t\t\tif ( hasMultiSelection() ) {\n\t\t\t\tif ( isNav ) {\n\t\t\t\t\tconst action = isShift ? expandSelection : moveSelection;\n\t\t\t\t\taction( isReverse );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// When presing any key other than up or down, the initial vertical\n\t\t\t// position must ALWAYS be reset. The vertical position is saved so\n\t\t\t// it can be restored as well as possible on sebsequent vertical\n\t\t\t// arrow key presses. It may not always be possible to restore the\n\t\t\t// exact same position (such as at an empty line), so it wouldn't be\n\t\t\t// good to compute the position right before any vertical arrow key\n\t\t\t// press.\n\t\t\tif ( ! isVertical ) {\n\t\t\t\tverticalRect = null;\n\t\t\t} else if ( ! verticalRect ) {\n\t\t\t\tverticalRect = computeCaretRect( defaultView );\n\t\t\t}\n\n\t\t\t// Abort if navigation has already been handled (e.g. RichText\n\t\t\t// inline boundaries).\n\t\t\tif ( event.defaultPrevented ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( ! isNav ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Abort if our current target is not a candidate for navigation\n\t\t\t// (e.g. preserve native input behaviors).\n\t\t\tif ( ! isNavigationCandidate( target, keyCode, hasModifier ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In the case of RTL scripts, right means previous and left means\n\t\t\t// next, which is the exact reverse of LTR.\n\t\t\tconst isReverseDir = isRTL( target ) ? ! isReverse : isReverse;\n\t\t\tconst { keepCaretInsideBlock } = getSettings();\n\t\t\tconst selectedBlockClientId = getSelectedBlockClientId();\n\n\t\t\tif ( isShift ) {\n\t\t\t\tconst selectionEndClientId = getMultiSelectedBlocksEndClientId();\n\t\t\t\tconst selectionBeforeEndClientId = getPreviousBlockClientId(\n\t\t\t\t\tselectionEndClientId || selectedBlockClientId\n\t\t\t\t);\n\t\t\t\tconst selectionAfterEndClientId = getNextBlockClientId(\n\t\t\t\t\tselectionEndClientId || selectedBlockClientId\n\t\t\t\t);\n\n\t\t\t\tif (\n\t\t\t\t\t// Ensure that there is a target block.\n\t\t\t\t\t( ( isReverse && selectionBeforeEndClientId ) ||\n\t\t\t\t\t\t( ! isReverse && selectionAfterEndClientId ) ) &&\n\t\t\t\t\tisTabbableEdge( target, isReverse ) &&\n\t\t\t\t\tisNavEdge( target, isReverse )\n\t\t\t\t) {\n\t\t\t\t\t// Shift key is down, and there is multi selection or we're\n\t\t\t\t\t// at the end of the current block.\n\t\t\t\t\texpandSelection( isReverse );\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tisVertical &&\n\t\t\t\tisVerticalEdge( target, isReverse ) &&\n\t\t\t\t! keepCaretInsideBlock\n\t\t\t) {\n\t\t\t\tconst closestTabbable = getClosestTabbable(\n\t\t\t\t\ttarget,\n\t\t\t\t\tisReverse,\n\t\t\t\t\tnode,\n\t\t\t\t\ttrue\n\t\t\t\t);\n\n\t\t\t\tif ( closestTabbable ) {\n\t\t\t\t\tplaceCaretAtVerticalEdge(\n\t\t\t\t\t\tclosestTabbable,\n\t\t\t\t\t\tisReverse,\n\t\t\t\t\t\tverticalRect\n\t\t\t\t\t);\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tisHorizontal &&\n\t\t\t\tdefaultView.getSelection().isCollapsed &&\n\t\t\t\tisHorizontalEdge( target, isReverseDir ) &&\n\t\t\t\t! keepCaretInsideBlock\n\t\t\t) {\n\t\t\t\tconst closestTabbable = getClosestTabbable(\n\t\t\t\t\ttarget,\n\t\t\t\t\tisReverseDir,\n\t\t\t\t\tnode\n\t\t\t\t);\n\t\t\t\tplaceCaretAtHorizontalEdge( closestTabbable, isReverse );\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\n\t\tnode.addEventListener( 'mousedown', onMouseDown );\n\t\tnode.addEventListener( 'keydown', onKeyDown );\n\t\treturn () => {\n\t\t\tnode.removeEventListener( 'mousedown', onMouseDown );\n\t\t\tnode.removeEventListener( 'keydown', onKeyDown );\n\t\t};\n\t}, [] );\n}\n"]}