"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = placeCaretAtVerticalEdge;

var _placeCaretAtHorizontalEdge = _interopRequireDefault(require("./place-caret-at-horizontal-edge"));

var _hiddenCaretRangeFromPoint = _interopRequireDefault(require("./hidden-caret-range-from-point"));

var _assertIsDefined = require("../utils/assert-is-defined");

/**
 * Internal dependencies
 */

/**
 * Places the caret at the top or bottom of a given element.
 *
 * @param {HTMLElement} container           Focusable element.
 * @param {boolean}     isReverse           True for bottom, false for top.
 * @param {DOMRect}     [rect]              The rectangle to position the caret with.
 * @param {boolean}     [mayUseScroll=true] True to allow scrolling, false to disallow.
 */
function placeCaretAtVerticalEdge(container, isReverse, rect, mayUseScroll = true) {
  if (!container) {
    return;
  }

  if (!rect || !container.isContentEditable) {
    (0, _placeCaretAtHorizontalEdge.default)(container, isReverse);
    return;
  }

  container.focus(); // Offset by a buffer half the height of the caret rect. This is needed
  // because caretRangeFromPoint may default to the end of the selection if
  // offset is too close to the edge. It's unclear how to precisely calculate
  // this threshold; it may be the padded area of some combination of line
  // height, caret height, and font size. The buffer offset is effectively
  // equivalent to a point at half the height of a line of text.

  const buffer = rect.height / 2;
  const editableRect = container.getBoundingClientRect();
  const x = rect.left;
  const y = isReverse ? editableRect.bottom - buffer : editableRect.top + buffer;
  const {
    ownerDocument
  } = container;
  const {
    defaultView
  } = ownerDocument;
  const range = (0, _hiddenCaretRangeFromPoint.default)(ownerDocument, x, y, container);

  if (!range || !container.contains(range.startContainer)) {
    if (mayUseScroll && (!range || !range.startContainer || !range.startContainer.contains(container))) {
      // Might be out of view.
      // Easier than attempting to calculate manually.
      container.scrollIntoView(isReverse);
      placeCaretAtVerticalEdge(container, isReverse, rect, false);
      return;
    }

    (0, _placeCaretAtHorizontalEdge.default)(container, isReverse);
    return;
  }

  (0, _assertIsDefined.assertIsDefined)(defaultView, 'defaultView');
  const selection = defaultView.getSelection();
  (0, _assertIsDefined.assertIsDefined)(selection, 'selection');
  selection.removeAllRanges();
  selection.addRange(range);
}
//# sourceMappingURL=place-caret-at-vertical-edge.js.map