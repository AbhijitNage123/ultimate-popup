{"version":3,"sources":["@wordpress/data/src/components/use-select/index.js"],"names":["useMemoOne","createQueue","useRef","useCallback","useReducer","useMemo","isShallowEqual","useIsomorphicLayoutEffect","useRegistry","useAsyncMode","renderQueue","useSelect","_mapSelect","deps","isWithoutMapping","mapSelect","registry","isAsync","queueContext","queue","forceRender","s","latestMapSelect","latestIsAsync","latestMapOutput","latestMapOutputError","isMountedAndNotUnsubscribing","listeningStores","trapSelect","callback","__experimentalMarkListeningStores","depsChangedFlag","mapOutput","current","select","error","errorMessage","message","stack","console","undefined","flush","onStoreChange","newMapOutput","add","onChange","unsubscribers","map","storeName","__experimentalSubscribeStore","forEach","unsubscribe"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { useMemoOne } from 'use-memo-one';\n\n/**\n * WordPress dependencies\n */\nimport { createQueue } from '@wordpress/priority-queue';\nimport { useRef, useCallback, useReducer, useMemo } from '@wordpress/element';\nimport isShallowEqual from '@wordpress/is-shallow-equal';\nimport { useIsomorphicLayoutEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport useRegistry from '../registry-provider/use-registry';\nimport useAsyncMode from '../async-mode-provider/use-async-mode';\n\nconst renderQueue = createQueue();\n\n/** @typedef {import('./types').WPDataStore} WPDataStore */\n\n/**\n * Custom react hook for retrieving props from registered selectors.\n *\n * In general, this custom React hook follows the\n * [rules of hooks](https://reactjs.org/docs/hooks-rules.html).\n *\n * @param {Function|WPDataStore|string} _mapSelect Function called on every state change. The\n *                                                 returned value is exposed to the component\n *                                                 implementing this hook. The function receives\n *                                                 the `registry.select` method on the first\n *                                                 argument and the `registry` on the second\n *                                                 argument.\n *                                                 When a store key is passed, all selectors for\n *                                                 the store will be returned. This is only meant\n *                                                 for usage of these selectors in event\n *                                                 callbacks, not for data needed to create the\n *                                                 element tree.\n * @param {Array}                       deps       If provided, this memoizes the mapSelect so the\n *                                                 same `mapSelect` is invoked on every state\n *                                                 change unless the dependencies change.\n *\n * @example\n * ```js\n * import { useSelect } from '@wordpress/data';\n *\n * function HammerPriceDisplay( { currency } ) {\n *   const price = useSelect( ( select ) => {\n *     return select( 'my-shop' ).getPrice( 'hammer', currency )\n *   }, [ currency ] );\n *   return new Intl.NumberFormat( 'en-US', {\n *     style: 'currency',\n *     currency,\n *   } ).format( price );\n * }\n *\n * // Rendered in the application:\n * // <HammerPriceDisplay currency=\"USD\" />\n * ```\n *\n * In the above example, when `HammerPriceDisplay` is rendered into an\n * application, the price will be retrieved from the store state using the\n * `mapSelect` callback on `useSelect`. If the currency prop changes then\n * any price in the state for that currency is retrieved. If the currency prop\n * doesn't change and other props are passed in that do change, the price will\n * not change because the dependency is just the currency.\n *\n * When data is only used in an event callback, the data should not be retrieved\n * on render, so it may be useful to get the selectors function instead.\n *\n * **Don't use `useSelect` this way when calling the selectors in the render\n * function because your component won't re-render on a data change.**\n *\n * ```js\n * import { useSelect } from '@wordpress/data';\n *\n * function Paste( { children } ) {\n *   const { getSettings } = useSelect( 'my-shop' );\n *   function onPaste() {\n *     // Do something with the settings.\n *     const settings = getSettings();\n *   }\n *   return <div onPaste={ onPaste }>{ children }</div>;\n * }\n * ```\n *\n * @return {Function}  A custom react hook.\n */\nexport default function useSelect( _mapSelect, deps ) {\n\tconst isWithoutMapping = typeof _mapSelect !== 'function';\n\n\tif ( isWithoutMapping ) {\n\t\tdeps = [];\n\t}\n\n\tconst mapSelect = useCallback( _mapSelect, deps );\n\tconst registry = useRegistry();\n\tconst isAsync = useAsyncMode();\n\t// React can sometimes clear the `useMemo` cache.\n\t// We use the cache-stable `useMemoOne` to avoid\n\t// losing queues.\n\tconst queueContext = useMemoOne( () => ( { queue: true } ), [ registry ] );\n\tconst [ , forceRender ] = useReducer( ( s ) => s + 1, 0 );\n\n\tconst latestMapSelect = useRef();\n\tconst latestIsAsync = useRef( isAsync );\n\tconst latestMapOutput = useRef();\n\tconst latestMapOutputError = useRef();\n\tconst isMountedAndNotUnsubscribing = useRef();\n\n\t// Keep track of the stores being selected in the mapSelect function,\n\t// and only subscribe to those stores later.\n\tconst listeningStores = useRef( [] );\n\tconst trapSelect = useCallback(\n\t\t( callback ) =>\n\t\t\tregistry.__experimentalMarkListeningStores(\n\t\t\t\tcallback,\n\t\t\t\tlisteningStores\n\t\t\t),\n\t\t[ registry ]\n\t);\n\n\t// Generate a \"flag\" for used in the effect dependency array.\n\t// It's different than just using `mapSelect` since deps could be undefined,\n\t// in that case, we would still want to memoize it.\n\tconst depsChangedFlag = useMemo( () => ( {} ), deps || [] );\n\n\tlet mapOutput;\n\n\tif ( ! isWithoutMapping ) {\n\t\ttry {\n\t\t\tif (\n\t\t\t\tlatestMapSelect.current !== mapSelect ||\n\t\t\t\tlatestMapOutputError.current\n\t\t\t) {\n\t\t\t\tmapOutput = trapSelect( () =>\n\t\t\t\t\tmapSelect( registry.select, registry )\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmapOutput = latestMapOutput.current;\n\t\t\t}\n\t\t} catch ( error ) {\n\t\t\tlet errorMessage = `An error occurred while running 'mapSelect': ${ error.message }`;\n\n\t\t\tif ( latestMapOutputError.current ) {\n\t\t\t\terrorMessage += `\\nThe error may be correlated with this previous error:\\n`;\n\t\t\t\terrorMessage += `${ latestMapOutputError.current.stack }\\n\\n`;\n\t\t\t\terrorMessage += 'Original stack trace:';\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error( errorMessage );\n\t\t\tmapOutput = latestMapOutput.current;\n\t\t}\n\t}\n\n\tuseIsomorphicLayoutEffect( () => {\n\t\tif ( isWithoutMapping ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlatestMapSelect.current = mapSelect;\n\t\tlatestMapOutput.current = mapOutput;\n\t\tlatestMapOutputError.current = undefined;\n\t\tisMountedAndNotUnsubscribing.current = true;\n\n\t\t// This has to run after the other ref updates\n\t\t// to avoid using stale values in the flushed\n\t\t// callbacks or potentially overwriting a\n\t\t// changed `latestMapOutput.current`.\n\t\tif ( latestIsAsync.current !== isAsync ) {\n\t\t\tlatestIsAsync.current = isAsync;\n\t\t\trenderQueue.flush( queueContext );\n\t\t}\n\t} );\n\n\tuseIsomorphicLayoutEffect( () => {\n\t\tif ( isWithoutMapping ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst onStoreChange = () => {\n\t\t\tif ( isMountedAndNotUnsubscribing.current ) {\n\t\t\t\ttry {\n\t\t\t\t\tconst newMapOutput = trapSelect( () =>\n\t\t\t\t\t\tlatestMapSelect.current( registry.select, registry )\n\t\t\t\t\t);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tisShallowEqual( latestMapOutput.current, newMapOutput )\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlatestMapOutput.current = newMapOutput;\n\t\t\t\t} catch ( error ) {\n\t\t\t\t\tlatestMapOutputError.current = error;\n\t\t\t\t}\n\t\t\t\tforceRender();\n\t\t\t}\n\t\t};\n\n\t\t// catch any possible state changes during mount before the subscription\n\t\t// could be set.\n\t\tif ( latestIsAsync.current ) {\n\t\t\trenderQueue.add( queueContext, onStoreChange );\n\t\t} else {\n\t\t\tonStoreChange();\n\t\t}\n\n\t\tconst onChange = () => {\n\t\t\tif ( latestIsAsync.current ) {\n\t\t\t\trenderQueue.add( queueContext, onStoreChange );\n\t\t\t} else {\n\t\t\t\tonStoreChange();\n\t\t\t}\n\t\t};\n\n\t\tconst unsubscribers = listeningStores.current.map( ( storeName ) =>\n\t\t\tregistry.__experimentalSubscribeStore( storeName, onChange )\n\t\t);\n\n\t\treturn () => {\n\t\t\tisMountedAndNotUnsubscribing.current = false;\n\t\t\t// The return value of the subscribe function could be undefined if the store is a custom generic store.\n\t\t\tunsubscribers.forEach( ( unsubscribe ) => unsubscribe?.() );\n\t\t\trenderQueue.flush( queueContext );\n\t\t};\n\t}, [ registry, trapSelect, depsChangedFlag, isWithoutMapping ] );\n\n\treturn isWithoutMapping ? registry.select( _mapSelect ) : mapOutput;\n}\n"]}