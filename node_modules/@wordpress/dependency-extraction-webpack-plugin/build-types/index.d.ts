export = DependencyExtractionWebpackPlugin;
/**
 * Map module request to an external.
 *
 * @callback RequestToExternal
 *
 * @param {string} request Module request.
 *
 * @return {string|string[]|void} Return `undefined` to ignore the request.
 *                                     Return `string|string[]` to map the request to an external.
 */
/**
 * Map module request to a script handle.
 *
 * @callback RequestToHandle
 *
 * @param {string} request Module request.
 *
 * @return {string|void} Return `undefined` to use the same name as the module.
 *                            Return `string` to map the request to a specific script handle.
 */
/**
 * @typedef AssetData
 *
 * @property {string}   version      String representing a particular build
 * @property {string[]} dependencies The script dependencies
 */
/**
 * @typedef Options
 *
 * @property {boolean}                     injectPolyfill      Force wp-polyfill to be included in each entry point's dependency list. This is like importing `@wordpress/polyfill` for each entry point.
 * @property {boolean}                     useDefaults         Set to `false` to disable the default WordPress script request handling.
 * @property {'php'|'json'}                outputFormat        The output format for the generated asset file.
 * @property {RequestToExternal|undefined} [requestToExternal] Map module requests to an external.
 * @property {RequestToHandle|undefined}   [requestToHandle]   Map module requests to a script handle.
 * @property {string|null}                 combinedOutputFile  This option is useful only when the combineAssets option is enabled. It allows providing a custom output file for the generated single assets file. It's possible to provide a path that is relative to the output directory.
 * @property {boolean|undefined}           combineAssets       By default, one asset file is created for each entry point. When this flag is set to true, all information about assets is combined into a single assets.(json|php) file generated in the output directory.
 */
declare class DependencyExtractionWebpackPlugin {
    /**
     * @param {Partial<Options>} options
     */
    constructor(options: Partial<Options>);
    /** @type {Options} */
    options: Options;
    /**
     * Track requests that are externalized.
     *
     * Because we don't have a closed set of dependencies, we need to track what has
     * been externalized so we can recognize them in a later phase when the dependency
     * lists are generated.
     *
     * @type {Set<string>}
     */
    externalizedDeps: Set<string>;
    externalsPlugin: import("webpack").ExternalsPlugin;
    /**
     * @param {Parameters<WebpackExternalsFunction>[0]} _context
     * @param {Parameters<WebpackExternalsFunction>[1]} request
     * @param {Parameters<WebpackExternalsFunction>[2]} callback
     */
    externalizeWpDeps(_context: [context: any, request: any, callback: import("webpack").ExternalsFunctionCallback][0], request: [context: any, request: any, callback: import("webpack").ExternalsFunctionCallback][1], callback: [context: any, request: any, callback: import("webpack").ExternalsFunctionCallback][2]): void;
    /**
     * @param {string} request
     * @return {string} Transformed request
     */
    mapRequestToDependency(request: string): string;
    /**
     * @param {Object} asset
     * @return {string} Stringified asset
     */
    stringify(asset: Object): string;
    /**
     * @param {WebpackCompiler} compiler
     * @return {void}
     */
    apply(compiler: WebpackCompiler): void;
}
declare namespace DependencyExtractionWebpackPlugin {
    export { RequestToExternal, RequestToHandle, AssetData, Options, WebpackCompiler, WebpackExternalsFunction };
}
type Options = {
    /**
     * Force wp-polyfill to be included in each entry point's dependency list. This is like importing `@wordpress/polyfill` for each entry point.
     */
    injectPolyfill: boolean;
    /**
     * Set to `false` to disable the default WordPress script request handling.
     */
    useDefaults: boolean;
    /**
     * The output format for the generated asset file.
     */
    outputFormat: 'php' | 'json';
    /**
     * Map module requests to an external.
     */
    requestToExternal?: RequestToExternal | undefined;
    /**
     * Map module requests to a script handle.
     */
    requestToHandle?: RequestToHandle | undefined;
    /**
     * This option is useful only when the combineAssets option is enabled. It allows providing a custom output file for the generated single assets file. It's possible to provide a path that is relative to the output directory.
     */
    combinedOutputFile: string | null;
    /**
     * By default, one asset file is created for each entry point. When this flag is set to true, all information about assets is combined into a single assets.(json|php) file generated in the output directory.
     */
    combineAssets: boolean | undefined;
};
type WebpackCompiler = import("webpack").Compiler;
/**
 * Map module request to an external.
 */
type RequestToExternal = (request: string) => string | string[] | void;
/**
 * Map module request to a script handle.
 */
type RequestToHandle = (request: string) => string | void;
type AssetData = {
    /**
     * String representing a particular build
     */
    version: string;
    /**
     * The script dependencies
     */
    dependencies: string[];
};
type WebpackExternalsFunction = (context: any, request: any, callback: import("webpack").ExternalsFunctionCallback) => any;
//# sourceMappingURL=index.d.ts.map