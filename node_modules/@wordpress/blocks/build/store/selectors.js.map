{"version":3,"sources":["@wordpress/blocks/src/store/selectors.js"],"names":["getNormalizedBlockType","state","nameOrType","getBlockType","getBlockTypes","Object","values","blockTypes","map","blockType","variations","getBlockVariations","name","blockVariations","getBlockStyles","blockStyles","blockName","scope","filter","variation","includes","getActiveBlockVariation","attributes","match","find","Array","isArray","isActive","attributeKeys","keys","definedAttributes","attribute","length","every","getDefaultBlockVariation","getCategories","categories","getCollections","collections","getDefaultBlockName","defaultBlockName","getFreeformFallbackBlockName","freeformFallbackBlockName","getUnregisteredFallbackBlockName","unregisteredFallbackBlockName","getGroupingBlockName","groupingBlockName","getChildBlockNames","parent","getBlockSupport","feature","defaultSupports","supports","hasBlockSupport","isMatchingSearchTerm","searchTerm","getNormalizedSearchTerm","deburr","term","toLowerCase","trim","normalizedSearchTerm","isSearchMatch","normalizedCandidate","title","keywords","category","hasChildBlocks","hasChildBlocksWithInserterSupport","childBlockName"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport {\n\tdeburr,\n\tfilter,\n\tfindLast,\n\tfirst,\n\tflow,\n\tget,\n\tincludes,\n\tmap,\n\tsome,\n} from 'lodash';\n\n/** @typedef {import('../api/registration').WPBlockVariation} WPBlockVariation */\n/** @typedef {import('../api/registration').WPBlockVariationScope} WPBlockVariationScope */\n/** @typedef {import('./reducer').WPBlockCategory} WPBlockCategory */\n\n/**\n * Given a block name or block type object, returns the corresponding\n * normalized block type object.\n *\n * @param {Object}          state      Blocks state.\n * @param {(string|Object)} nameOrType Block name or type object\n *\n * @return {Object} Block type object.\n */\nconst getNormalizedBlockType = ( state, nameOrType ) =>\n\t'string' === typeof nameOrType\n\t\t? getBlockType( state, nameOrType )\n\t\t: nameOrType;\n\n/**\n * Returns all the available block types.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Block Types.\n */\nexport const getBlockTypes = createSelector(\n\t( state ) => {\n\t\treturn Object.values( state.blockTypes ).map( ( blockType ) => {\n\t\t\treturn {\n\t\t\t\t...blockType,\n\t\t\t\tvariations: getBlockVariations( state, blockType.name ),\n\t\t\t};\n\t\t} );\n\t},\n\t( state ) => [ state.blockTypes, state.blockVariations ]\n);\n\n/**\n * Returns a block type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Block type name.\n *\n * @return {Object?} Block Type.\n */\nexport function getBlockType( state, name ) {\n\treturn state.blockTypes[ name ];\n}\n\n/**\n * Returns block styles by block name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Block type name.\n *\n * @return {Array?} Block Styles.\n */\nexport function getBlockStyles( state, name ) {\n\treturn state.blockStyles[ name ];\n}\n\n/**\n * Returns block variations by block name.\n *\n * @param {Object}                state     Data state.\n * @param {string}                blockName Block type name.\n * @param {WPBlockVariationScope} [scope]   Block variation scope name.\n *\n * @return {(WPBlockVariation[]|void)} Block variations.\n */\nexport const getBlockVariations = createSelector(\n\t( state, blockName, scope ) => {\n\t\tconst variations = state.blockVariations[ blockName ];\n\t\tif ( ! variations || ! scope ) {\n\t\t\treturn variations;\n\t\t}\n\t\treturn variations.filter( ( variation ) => {\n\t\t\t// For backward compatibility reasons, variation's scope defaults to\n\t\t\t// `block` and `inserter` when not set.\n\t\t\treturn ( variation.scope || [ 'block', 'inserter' ] ).includes(\n\t\t\t\tscope\n\t\t\t);\n\t\t} );\n\t},\n\t( state, blockName ) => [ state.blockVariations[ blockName ] ]\n);\n\n/**\n * Returns the active block variation for a given block based on its attributes.\n * Variations are determined by their `isActive` property.\n * Which is either an array of block attribute keys or a function.\n *\n * In case of an array of block attribute keys, the `attributes` are compared\n * to the variation's attributes using strict equality check.\n *\n * In case of function type, the function should accept a block's attributes\n * and the variation's attributes and determines if a variation is active.\n * A function that accepts a block's attributes and the variation's attributes and determines if a variation is active.\n *\n * @param {Object}                state      Data state.\n * @param {string}                blockName  Name of block (example: “core/columns”).\n * @param {Object}                attributes Block attributes used to determine active variation.\n * @param {WPBlockVariationScope} [scope]    Block variation scope name.\n *\n * @return {(WPBlockVariation|undefined)} Active block variation.\n */\nexport function getActiveBlockVariation( state, blockName, attributes, scope ) {\n\tconst variations = getBlockVariations( state, blockName, scope );\n\n\tconst match = variations?.find( ( variation ) => {\n\t\tif ( Array.isArray( variation.isActive ) ) {\n\t\t\tconst blockType = getBlockType( state, blockName );\n\t\t\tconst attributeKeys = Object.keys( blockType.attributes || {} );\n\t\t\tconst definedAttributes = variation.isActive.filter(\n\t\t\t\t( attribute ) => attributeKeys.includes( attribute )\n\t\t\t);\n\t\t\tif ( definedAttributes.length === 0 ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn definedAttributes.every(\n\t\t\t\t( attribute ) =>\n\t\t\t\t\tattributes[ attribute ] ===\n\t\t\t\t\tvariation.attributes[ attribute ]\n\t\t\t);\n\t\t}\n\n\t\treturn variation.isActive?.( attributes, variation.attributes );\n\t} );\n\n\treturn match;\n}\n\n/**\n * Returns the default block variation for the given block type.\n * When there are multiple variations annotated as the default one,\n * the last added item is picked. This simplifies registering overrides.\n * When there is no default variation set, it returns the first item.\n *\n * @param {Object}                state     Data state.\n * @param {string}                blockName Block type name.\n * @param {WPBlockVariationScope} [scope]   Block variation scope name.\n *\n * @return {?WPBlockVariation} The default block variation.\n */\nexport function getDefaultBlockVariation( state, blockName, scope ) {\n\tconst variations = getBlockVariations( state, blockName, scope );\n\n\treturn findLast( variations, 'isDefault' ) || first( variations );\n}\n\n/**\n * Returns all the available categories.\n *\n * @param {Object} state Data state.\n *\n * @return {WPBlockCategory[]} Categories list.\n */\nexport function getCategories( state ) {\n\treturn state.categories;\n}\n\n/**\n * Returns all the available collections.\n *\n * @param {Object} state Data state.\n *\n * @return {Object} Collections list.\n */\nexport function getCollections( state ) {\n\treturn state.collections;\n}\n\n/**\n * Returns the name of the default block name.\n *\n * @param {Object} state Data state.\n *\n * @return {string?} Default block name.\n */\nexport function getDefaultBlockName( state ) {\n\treturn state.defaultBlockName;\n}\n\n/**\n * Returns the name of the block for handling non-block content.\n *\n * @param {Object} state Data state.\n *\n * @return {string?} Name of the block for handling non-block content.\n */\nexport function getFreeformFallbackBlockName( state ) {\n\treturn state.freeformFallbackBlockName;\n}\n\n/**\n * Returns the name of the block for handling unregistered blocks.\n *\n * @param {Object} state Data state.\n *\n * @return {string?} Name of the block for handling unregistered blocks.\n */\nexport function getUnregisteredFallbackBlockName( state ) {\n\treturn state.unregisteredFallbackBlockName;\n}\n\n/**\n * Returns the name of the block for handling unregistered blocks.\n *\n * @param {Object} state Data state.\n *\n * @return {string?} Name of the block for handling unregistered blocks.\n */\nexport function getGroupingBlockName( state ) {\n\treturn state.groupingBlockName;\n}\n\n/**\n * Returns an array with the child blocks of a given block.\n *\n * @param {Object} state     Data state.\n * @param {string} blockName Block type name.\n *\n * @return {Array} Array of child block names.\n */\nexport const getChildBlockNames = createSelector(\n\t( state, blockName ) => {\n\t\treturn map(\n\t\t\tfilter( state.blockTypes, ( blockType ) => {\n\t\t\t\treturn includes( blockType.parent, blockName );\n\t\t\t} ),\n\t\t\t( { name } ) => name\n\t\t);\n\t},\n\t( state ) => [ state.blockTypes ]\n);\n\n/**\n * Returns the block support value for a feature, if defined.\n *\n * @param {Object}          state           Data state.\n * @param {(string|Object)} nameOrType      Block name or type object\n * @param {Array|string}    feature         Feature to retrieve\n * @param {*}               defaultSupports Default value to return if not\n *                                          explicitly defined\n *\n * @return {?*} Block support value\n */\nexport const getBlockSupport = (\n\tstate,\n\tnameOrType,\n\tfeature,\n\tdefaultSupports\n) => {\n\tconst blockType = getNormalizedBlockType( state, nameOrType );\n\tif ( ! blockType?.supports ) {\n\t\treturn defaultSupports;\n\t}\n\n\treturn get( blockType.supports, feature, defaultSupports );\n};\n\n/**\n * Returns true if the block defines support for a feature, or false otherwise.\n *\n * @param {Object}          state           Data state.\n * @param {(string|Object)} nameOrType      Block name or type object.\n * @param {string}          feature         Feature to test.\n * @param {boolean}         defaultSupports Whether feature is supported by\n *                                          default if not explicitly defined.\n *\n * @return {boolean} Whether block supports feature.\n */\nexport function hasBlockSupport( state, nameOrType, feature, defaultSupports ) {\n\treturn !! getBlockSupport( state, nameOrType, feature, defaultSupports );\n}\n\n/**\n * Returns true if the block type by the given name or object value matches a\n * search term, or false otherwise.\n *\n * @param {Object}          state      Blocks state.\n * @param {(string|Object)} nameOrType Block name or type object.\n * @param {string}          searchTerm Search term by which to filter.\n *\n * @return {Object[]} Whether block type matches search term.\n */\nexport function isMatchingSearchTerm( state, nameOrType, searchTerm ) {\n\tconst blockType = getNormalizedBlockType( state, nameOrType );\n\n\tconst getNormalizedSearchTerm = flow( [\n\t\t// Disregard diacritics.\n\t\t//  Input: \"média\"\n\t\tdeburr,\n\n\t\t// Lowercase.\n\t\t//  Input: \"MEDIA\"\n\t\t( term ) => term.toLowerCase(),\n\n\t\t// Strip leading and trailing whitespace.\n\t\t//  Input: \" media \"\n\t\t( term ) => term.trim(),\n\t] );\n\n\tconst normalizedSearchTerm = getNormalizedSearchTerm( searchTerm );\n\n\tconst isSearchMatch = flow( [\n\t\tgetNormalizedSearchTerm,\n\t\t( normalizedCandidate ) =>\n\t\t\tincludes( normalizedCandidate, normalizedSearchTerm ),\n\t] );\n\n\treturn (\n\t\tisSearchMatch( blockType.title ) ||\n\t\tsome( blockType.keywords, isSearchMatch ) ||\n\t\tisSearchMatch( blockType.category )\n\t);\n}\n\n/**\n * Returns a boolean indicating if a block has child blocks or not.\n *\n * @param {Object} state     Data state.\n * @param {string} blockName Block type name.\n *\n * @return {boolean} True if a block contains child blocks and false otherwise.\n */\nexport const hasChildBlocks = ( state, blockName ) => {\n\treturn getChildBlockNames( state, blockName ).length > 0;\n};\n\n/**\n * Returns a boolean indicating if a block has at least one child block with inserter support.\n *\n * @param {Object} state     Data state.\n * @param {string} blockName Block type name.\n *\n * @return {boolean} True if a block contains at least one child blocks with inserter support\n *                   and false otherwise.\n */\nexport const hasChildBlocksWithInserterSupport = ( state, blockName ) => {\n\treturn some( getChildBlockNames( state, blockName ), ( childBlockName ) => {\n\t\treturn hasBlockSupport( state, childBlockName, 'inserter', true );\n\t} );\n};\n"]}