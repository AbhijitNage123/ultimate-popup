"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doBlocksMatchTemplate = doBlocksMatchTemplate;
exports.synchronizeBlocksWithTemplate = synchronizeBlocksWithTemplate;

var _lodash = require("lodash");

var _element = require("@wordpress/element");

var _parser = require("./parser");

var _factory = require("./factory");

var _registration = require("./registration");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Checks whether a list of blocks matches a template by comparing the block names.
 *
 * @param {Array} blocks   Block list.
 * @param {Array} template Block template.
 *
 * @return {boolean} Whether the list of blocks matches a templates.
 */
function doBlocksMatchTemplate(blocks = [], template = []) {
  return blocks.length === template.length && (0, _lodash.every)(template, ([name,, innerBlocksTemplate], index) => {
    const block = blocks[index];
    return name === block.name && doBlocksMatchTemplate(block.innerBlocks, innerBlocksTemplate);
  });
}
/**
 * Synchronize a block list with a block template.
 *
 * Synchronizing a block list with a block template means that we loop over the blocks
 * keep the block as is if it matches the block at the same position in the template
 * (If it has the same name) and if doesn't match, we create a new block based on the template.
 * Extra blocks not present in the template are removed.
 *
 * @param {Array} blocks   Block list.
 * @param {Array} template Block template.
 *
 * @return {Array} Updated Block list.
 */


function synchronizeBlocksWithTemplate(blocks = [], template) {
  // If no template is provided, return blocks unmodified.
  if (!template) {
    return blocks;
  }

  return (0, _lodash.map)(template, ([name, attributes, innerBlocksTemplate], index) => {
    const block = blocks[index];

    if (block && block.name === name) {
      const innerBlocks = synchronizeBlocksWithTemplate(block.innerBlocks, innerBlocksTemplate);
      return { ...block,
        innerBlocks
      };
    } // To support old templates that were using the "children" format
    // for the attributes using "html" strings now, we normalize the template attributes
    // before creating the blocks.


    const blockType = (0, _registration.getBlockType)(name);

    const isHTMLAttribute = attributeDefinition => (0, _lodash.get)(attributeDefinition, ['source']) === 'html';

    const isQueryAttribute = attributeDefinition => (0, _lodash.get)(attributeDefinition, ['source']) === 'query';

    const normalizeAttributes = (schema, values) => {
      return (0, _lodash.mapValues)(values, (value, key) => {
        return normalizeAttribute(schema[key], value);
      });
    };

    const normalizeAttribute = (definition, value) => {
      if (isHTMLAttribute(definition) && (0, _lodash.isArray)(value)) {
        // Introduce a deprecated call at this point
        // When we're confident that "children" format should be removed from the templates.
        return (0, _element.renderToString)(value);
      }

      if (isQueryAttribute(definition) && value) {
        return value.map(subValues => {
          return normalizeAttributes(definition.query, subValues);
        });
      }

      return value;
    };

    const normalizedAttributes = normalizeAttributes((0, _lodash.get)(blockType, ['attributes'], {}), attributes);
    const {
      name: blockName,
      attributes: blockAttributes
    } = (0, _parser.convertLegacyBlocks)(name, normalizedAttributes);
    return (0, _factory.createBlock)(blockName, blockAttributes, synchronizeBlocksWithTemplate([], innerBlocksTemplate));
  });
}
//# sourceMappingURL=templates.js.map