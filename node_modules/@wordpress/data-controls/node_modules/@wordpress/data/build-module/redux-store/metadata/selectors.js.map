{"version":3,"sources":["@wordpress/data/src/redux-store/metadata/selectors.js"],"names":["get","getIsResolving","state","selectorName","args","map","undefined","hasStartedResolution","hasFinishedResolution","isResolving","getCachedResolvers"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,GAAT,QAAoB,QAApB;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAyBC,KAAzB,EAAgCC,YAAhC,EAA8CC,IAA9C,EAAqD;AAC3D,QAAMC,GAAG,GAAGL,GAAG,CAAEE,KAAF,EAAS,CAAEC,YAAF,CAAT,CAAf;;AACA,MAAK,CAAEE,GAAP,EAAa;AACZ,WAAOC,SAAP;AACA;;AAED,SAAOD,GAAG,CAACL,GAAJ,CAASI,IAAT,CAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,oBAAT,CAA+BL,KAA/B,EAAsCC,YAAtC,EAAoDC,IAAI,GAAG,EAA3D,EAAgE;AACtE,SAAOH,cAAc,CAAEC,KAAF,EAASC,YAAT,EAAuBC,IAAvB,CAAd,KAAgDE,SAAvD;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,qBAAT,CAAgCN,KAAhC,EAAuCC,YAAvC,EAAqDC,IAAI,GAAG,EAA5D,EAAiE;AACvE,SAAOH,cAAc,CAAEC,KAAF,EAASC,YAAT,EAAuBC,IAAvB,CAAd,KAAgD,KAAvD;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,WAAT,CAAsBP,KAAtB,EAA6BC,YAA7B,EAA2CC,IAAI,GAAG,EAAlD,EAAuD;AAC7D,SAAOH,cAAc,CAAEC,KAAF,EAASC,YAAT,EAAuBC,IAAvB,CAAd,KAAgD,IAAvD;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,kBAAT,CAA6BR,KAA7B,EAAqC;AAC3C,SAAOA,KAAP;AACA","sourcesContent":["/**\n * External dependencies\n */\nimport { get } from 'lodash';\n\n/** @typedef {Record<string, import('./reducer').State>} State */\n\n/**\n * Returns the raw `isResolving` value for a given selector name,\n * and arguments set. May be undefined if the selector has never been resolved\n * or not resolved for the given set of arguments, otherwise true or false for\n * resolution started and completed respectively.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} args         Arguments passed to selector.\n *\n * @return {boolean | undefined} isResolving value.\n */\nexport function getIsResolving( state, selectorName, args ) {\n\tconst map = get( state, [ selectorName ] );\n\tif ( ! map ) {\n\t\treturn undefined;\n\t}\n\n\treturn map.get( args );\n}\n\n/**\n * Returns true if resolution has already been triggered for a given\n * selector name, and arguments set.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} [args]       Arguments passed to selector (default `[]`).\n *\n * @return {boolean} Whether resolution has been triggered.\n */\nexport function hasStartedResolution( state, selectorName, args = [] ) {\n\treturn getIsResolving( state, selectorName, args ) !== undefined;\n}\n\n/**\n * Returns true if resolution has completed for a given selector\n * name, and arguments set.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} [args]       Arguments passed to selector.\n *\n * @return {boolean} Whether resolution has completed.\n */\nexport function hasFinishedResolution( state, selectorName, args = [] ) {\n\treturn getIsResolving( state, selectorName, args ) === false;\n}\n\n/**\n * Returns true if resolution has been triggered but has not yet completed for\n * a given selector name, and arguments set.\n *\n * @param {State}     state        Data state.\n * @param {string}    selectorName Selector name.\n * @param {unknown[]} [args]       Arguments passed to selector.\n *\n * @return {boolean} Whether resolution is in progress.\n */\nexport function isResolving( state, selectorName, args = [] ) {\n\treturn getIsResolving( state, selectorName, args ) === true;\n}\n\n/**\n * Returns the list of the cached resolvers.\n *\n * @param {State} state Data state.\n *\n * @return {State} Resolvers mapped by args and selectorName.\n */\nexport function getCachedResolvers( state ) {\n\treturn state;\n}\n"]}